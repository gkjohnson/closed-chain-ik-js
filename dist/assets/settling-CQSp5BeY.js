import{n as un,V as D,o as fn,p as ot,f as Tt,T as Et,h as pn,q as dt,B as et,r as Pn,s as Bn,u as Sn,F as $e,M as Gt,v as Mn,w as Cn,x as dn,R as _n,W as En,d as Dn,P as Rn,S as Ln,C as Fn,D as vn,A as In,G as Un,y as Nn,z as Vn,g as zn,J as at,L as lt,a as W,I as We,E as ht,b as kn,c as qn,e as Xe}from"./IKRootsHelper-DmBdh0X7.js";import{S as Hn,O as $n,T as Wn}from"./stats.module-BFsq5STz.js";import{G as me}from"./Goal-DJOimEJ_.js";import{U as Xn,S as jn,u as Zn,s as Gn,a as yn}from"./URDFLoader-Dz40SxeK.js";import{G as Yn}from"./GLTFLoader-kDl-WrEj.js";const hn=0,Jn=1,On=2,je=2,we=1.25,Ze=1,Xt=6*4+4+4,ye=65535,Kn=Math.pow(2,-24),xe=Symbol("SKIP_GENERATION");function Qn(n){return n.index?n.index.count:n.attributes.position.count}function Rt(n){return Qn(n)/3}function ts(n,e=ArrayBuffer){return n>65535?new Uint32Array(new e(4*n)):new Uint16Array(new e(2*n))}function es(n,e){if(!n.index){const t=n.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=ts(t,s);n.setIndex(new un(o,1));for(let c=0;c<t;c++)o[c]=c}}function mn(n,e){const t=Rt(n),s=e||n.drawRange,o=s.start/3,c=(s.start+s.count)/3,i=Math.max(0,o),a=Math.min(t,c)-i;return[{offset:Math.floor(i),count:Math.floor(a)}]}function wn(n,e){if(!n.groups||!n.groups.length)return mn(n,e);const t=[],s=new Set,o=e||n.drawRange,c=o.start/3,i=(o.start+o.count)/3;for(const r of n.groups){const p=r.start/3,u=(r.start+r.count)/3;s.add(Math.max(c,p)),s.add(Math.min(i,u))}const a=Array.from(s.values()).sort((r,p)=>r-p);for(let r=0;r<a.length-1;r++){const p=a[r],u=a[r+1];t.push({offset:Math.floor(p),count:Math.floor(u-p)})}return t}function ns(n,e){const t=Rt(n),s=wn(n,e).sort((i,a)=>i.offset-a.offset),o=s[s.length-1];o.count=Math.min(t-o.offset,o.count);let c=0;return s.forEach(({count:i})=>c+=i),t!==c}function ge(n,e,t,s,o){let c=1/0,i=1/0,a=1/0,r=-1/0,p=-1/0,u=-1/0,f=1/0,l=1/0,d=1/0,A=-1/0,b=-1/0,m=-1/0;for(let h=e*6,y=(e+t)*6;h<y;h+=6){const w=n[h+0],g=n[h+1],x=w-g,P=w+g;x<c&&(c=x),P>r&&(r=P),w<f&&(f=w),w>A&&(A=w);const T=n[h+2],C=n[h+3],B=T-C,_=T+C;B<i&&(i=B),_>p&&(p=_),T<l&&(l=T),T>b&&(b=T);const S=n[h+4],M=n[h+5],E=S-M,R=S+M;E<a&&(a=E),R>u&&(u=R),S<d&&(d=S),S>m&&(m=S)}s[0]=c,s[1]=i,s[2]=a,s[3]=r,s[4]=p,s[5]=u,o[0]=f,o[1]=l,o[2]=d,o[3]=A,o[4]=b,o[5]=m}function ss(n,e=null,t=null,s=null){const o=n.attributes.position,c=n.index?n.index.array:null,i=Rt(n),a=o.normalized;let r;e===null?(r=new Float32Array(i*6),t=0,s=i):(r=e,t=t||0,s=s||i);const p=o.array,u=o.offset||0;let f=3;o.isInterleavedBufferAttribute&&(f=o.data.stride);const l=["getX","getY","getZ"];for(let d=t;d<t+s;d++){const A=d*3,b=d*6;let m=A+0,h=A+1,y=A+2;c&&(m=c[m],h=c[h],y=c[y]),a||(m=m*f+u,h=h*f+u,y=y*f+u);for(let w=0;w<3;w++){let g,x,P;a?(g=o[l[w]](m),x=o[l[w]](h),P=o[l[w]](y)):(g=p[m+w],x=p[h+w],P=p[y+w]);let T=g;x<T&&(T=x),P<T&&(T=P);let C=g;x>C&&(C=x),P>C&&(C=P);const B=(C-T)/2,_=w*2;r[b+_+0]=T+B,r[b+_+1]=B+(Math.abs(T)+B)*Kn}}return r}function I(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}function Ge(n){let e=-1,t=-1/0;for(let s=0;s<3;s++){const o=n[s+3]-n[s];o>t&&(t=o,e=s)}return e}function Ye(n,e){e.set(n)}function Je(n,e,t){let s,o;for(let c=0;c<3;c++){const i=c+3;s=n[c],o=e[c],t[c]=s<o?s:o,s=n[i],o=e[i],t[i]=s>o?s:o}}function Yt(n,e,t){for(let s=0;s<3;s++){const o=e[n+2*s],c=e[n+2*s+1],i=o-c,a=o+c;i<t[s]&&(t[s]=i),a>t[s+3]&&(t[s+3]=a)}}function vt(n){const e=n[3]-n[0],t=n[4]-n[1],s=n[5]-n[2];return 2*(e*t+t*s+s*e)}const nt=32,is=(n,e)=>n.candidate-e.candidate,ut=new Array(nt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Jt=new Float32Array(6);function os(n,e,t,s,o,c){let i=-1,a=0;if(c===hn)i=Ge(e),i!==-1&&(a=(e[i]+e[i+3])/2);else if(c===Jn)i=Ge(n),i!==-1&&(a=rs(t,s,o,i));else if(c===On){const r=vt(n);let p=we*o;const u=s*6,f=(s+o)*6;for(let l=0;l<3;l++){const d=e[l],m=(e[l+3]-d)/nt;if(o<nt/4){const h=[...ut];h.length=o;let y=0;for(let g=u;g<f;g+=6,y++){const x=h[y];x.candidate=t[g+2*l],x.count=0;const{bounds:P,leftCacheBounds:T,rightCacheBounds:C}=x;for(let B=0;B<3;B++)C[B]=1/0,C[B+3]=-1/0,T[B]=1/0,T[B+3]=-1/0,P[B]=1/0,P[B+3]=-1/0;Yt(g,t,P)}h.sort(is);let w=o;for(let g=0;g<w;g++){const x=h[g];for(;g+1<w&&h[g+1].candidate===x.candidate;)h.splice(g+1,1),w--}for(let g=u;g<f;g+=6){const x=t[g+2*l];for(let P=0;P<w;P++){const T=h[P];x>=T.candidate?Yt(g,t,T.rightCacheBounds):(Yt(g,t,T.leftCacheBounds),T.count++)}}for(let g=0;g<w;g++){const x=h[g],P=x.count,T=o-x.count,C=x.leftCacheBounds,B=x.rightCacheBounds;let _=0;P!==0&&(_=vt(C)/r);let S=0;T!==0&&(S=vt(B)/r);const M=Ze+we*(_*P+S*T);M<p&&(i=l,p=M,a=x.candidate)}}else{for(let w=0;w<nt;w++){const g=ut[w];g.count=0,g.candidate=d+m+w*m;const x=g.bounds;for(let P=0;P<3;P++)x[P]=1/0,x[P+3]=-1/0}for(let w=u;w<f;w+=6){let P=~~((t[w+2*l]-d)/m);P>=nt&&(P=nt-1);const T=ut[P];T.count++,Yt(w,t,T.bounds)}const h=ut[nt-1];Ye(h.bounds,h.rightCacheBounds);for(let w=nt-2;w>=0;w--){const g=ut[w],x=ut[w+1];Je(g.bounds,x.rightCacheBounds,g.rightCacheBounds)}let y=0;for(let w=0;w<nt-1;w++){const g=ut[w],x=g.count,P=g.bounds,C=ut[w+1].rightCacheBounds;x!==0&&(y===0?Ye(P,Jt):Je(P,Jt,Jt)),y+=x;let B=0,_=0;y!==0&&(B=vt(Jt)/r);const S=o-y;S!==0&&(_=vt(C)/r);const M=Ze+we*(B*y+_*S);M<p&&(i=l,p=M,a=g.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:i,pos:a}}function rs(n,e,t,s){let o=0;for(let c=e,i=e+t;c<i;c++)o+=n[c*6+s*2];return o/t}class Ae{constructor(){this.boundingData=new Float32Array(6)}}function cs(n,e,t,s,o,c){let i=s,a=s+o-1;const r=c.pos,p=c.axis*2;for(;;){for(;i<=a&&t[i*6+p]<r;)i++;for(;i<=a&&t[a*6+p]>=r;)a--;if(i<a){for(let u=0;u<3;u++){let f=e[i*3+u];e[i*3+u]=e[a*3+u],e[a*3+u]=f}for(let u=0;u<6;u++){let f=t[i*6+u];t[i*6+u]=t[a*6+u],t[a*6+u]=f}i++,a--}else return i}}function as(n,e,t,s,o,c){let i=s,a=s+o-1;const r=c.pos,p=c.axis*2;for(;;){for(;i<=a&&t[i*6+p]<r;)i++;for(;i<=a&&t[a*6+p]>=r;)a--;if(i<a){let u=n[i];n[i]=n[a],n[a]=u;for(let f=0;f<6;f++){let l=t[i*6+f];t[i*6+f]=t[a*6+f],t[a*6+f]=l}i++,a--}else return i}}function $(n,e){return e[n+15]===65535}function Z(n,e){return e[n+6]}function G(n,e){return e[n+14]}function Y(n){return n+8}function J(n,e){return e[n+6]}function xn(n,e){return e[n+7]}let gn,$t,fe,An;const ls=Math.pow(2,32);function _e(n){return"count"in n?1:1+_e(n.left)+_e(n.right)}function us(n,e,t){return gn=new Float32Array(t),$t=new Uint32Array(t),fe=new Uint16Array(t),An=new Uint8Array(t),Ee(n,e)}function Ee(n,e){const t=n/4,s=n/2,o="count"in e,c=e.boundingData;for(let i=0;i<6;i++)gn[t+i]=c[i];if(o)if(e.buffer){const i=e.buffer;An.set(new Uint8Array(i),n);for(let a=n,r=n+i.byteLength;a<r;a+=Xt){const p=a/2;$(p,fe)||($t[a/4+6]+=t)}return n+i.byteLength}else{const i=e.offset,a=e.count;return $t[t+6]=i,fe[s+14]=a,fe[s+15]=ye,n+Xt}else{const i=e.left,a=e.right,r=e.splitAxis;let p;if(p=Ee(n+Xt,i),p/4>ls)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return $t[t+6]=p/4,p=Ee(p,a),$t[t+7]=r,p}}function fs(n,e){const t=(n.index?n.index.count:n.attributes.position.count)/3,s=t>2**16,o=s?4:2,c=e?new SharedArrayBuffer(t*o):new ArrayBuffer(t*o),i=s?new Uint32Array(c):new Uint16Array(c);for(let a=0,r=i.length;a<r;a++)i[a]=a;return i}function ps(n,e,t,s,o){const{maxDepth:c,verbose:i,maxLeafTris:a,strategy:r,onProgress:p,indirect:u}=o,f=n._indirectBuffer,l=n.geometry,d=l.index?l.index.array:null,A=u?as:cs,b=Rt(l),m=new Float32Array(6);let h=!1;const y=new Ae;return ge(e,t,s,y.boundingData,m),g(y,t,s,m),y;function w(x){p&&p(x/b)}function g(x,P,T,C=null,B=0){if(!h&&B>=c&&(h=!0,i&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(l))),T<=a||B>=c)return w(P+T),x.offset=P,x.count=T,x;const _=os(x.boundingData,C,e,P,T,r);if(_.axis===-1)return w(P+T),x.offset=P,x.count=T,x;const S=A(f,d,e,P,T,_);if(S===P||S===P+T)w(P+T),x.offset=P,x.count=T;else{x.splitAxis=_.axis;const M=new Ae,E=P,R=S-P;x.left=M,ge(e,E,R,M.boundingData,m),g(M,E,R,m,B+1);const L=new Ae,U=S,ct=T-R;x.right=L,ge(e,U,ct,L.boundingData,m),g(L,U,ct,m,B+1)}return x}}function ds(n,e){const t=n.geometry;e.indirect&&(n._indirectBuffer=fs(t,e.useSharedArrayBuffer),ns(t,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||es(t,e);const s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=ss(t),c=e.indirect?mn(t,e.range):wn(t,e.range);n._roots=c.map(i=>{const a=ps(n,o,i.offset,i.count,e),r=_e(a),p=new s(Xt*r);return us(0,a,p),p})}class rt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let s=1/0,o=-1/0;for(let c=0,i=e.length;c<i;c++){const r=e[c][t];s=r<s?r:s,o=r>o?r:o}this.min=s,this.max=o}setFromPoints(e,t){let s=1/0,o=-1/0;for(let c=0,i=t.length;c<i;c++){const a=t[c],r=e.dot(a);s=r<s?r:s,o=r>o?r:o}this.min=s,this.max=o}isSeparated(e){return this.min>e.max||e.min>this.max}}rt.prototype.setFromBox=function(){const n=new D;return function(t,s){const o=s.min,c=s.max;let i=1/0,a=-1/0;for(let r=0;r<=1;r++)for(let p=0;p<=1;p++)for(let u=0;u<=1;u++){n.x=o.x*r+c.x*(1-r),n.y=o.y*p+c.y*(1-p),n.z=o.z*u+c.z*(1-u);const f=t.dot(n);i=Math.min(f,i),a=Math.max(f,a)}this.min=i,this.max=a}}();const ys=function(){const n=new D,e=new D,t=new D;return function(o,c,i){const a=o.start,r=n,p=c.start,u=e;t.subVectors(a,p),n.subVectors(o.end,o.start),e.subVectors(c.end,c.start);const f=t.dot(u),l=u.dot(r),d=u.dot(u),A=t.dot(r),m=r.dot(r)*d-l*l;let h,y;m!==0?h=(f*l-A*d)/m:h=0,y=(f+h*l)/d,i.x=h,i.y=y}}(),ke=function(){const n=new Tt,e=new D,t=new D;return function(o,c,i,a){ys(o,c,n);let r=n.x,p=n.y;if(r>=0&&r<=1&&p>=0&&p<=1){o.at(r,i),c.at(p,a);return}else if(r>=0&&r<=1){p<0?c.at(0,a):c.at(1,a),o.closestPointToPoint(a,!0,i);return}else if(p>=0&&p<=1){r<0?o.at(0,i):o.at(1,i),c.closestPointToPoint(i,!0,a);return}else{let u;r<0?u=o.start:u=o.end;let f;p<0?f=c.start:f=c.end;const l=e,d=t;if(o.closestPointToPoint(f,!0,e),c.closestPointToPoint(u,!0,t),l.distanceToSquared(f)<=d.distanceToSquared(u)){i.copy(l),a.copy(f);return}else{i.copy(u),a.copy(d);return}}}}(),hs=function(){const n=new D,e=new D,t=new fn,s=new ot;return function(c,i){const{radius:a,center:r}=c,{a:p,b:u,c:f}=i;if(s.start=p,s.end=u,s.closestPointToPoint(r,!0,n).distanceTo(r)<=a||(s.start=p,s.end=f,s.closestPointToPoint(r,!0,n).distanceTo(r)<=a)||(s.start=u,s.end=f,s.closestPointToPoint(r,!0,n).distanceTo(r)<=a))return!0;const b=i.getPlane(t);if(Math.abs(b.distanceToPoint(r))<=a){const h=b.projectPoint(r,e);if(i.containsPoint(h))return!0}return!1}}(),ms=1e-15;function Te(n){return Math.abs(n)<ms}class tt extends Et{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new D),this.satBounds=new Array(4).fill().map(()=>new rt),this.points=[this.a,this.b,this.c],this.sphere=new pn,this.plane=new fn,this.needsUpdate=!0}intersectsSphere(e){return hs(e,this)}update(){const e=this.a,t=this.b,s=this.c,o=this.points,c=this.satAxes,i=this.satBounds,a=c[0],r=i[0];this.getNormal(a),r.setFromPoints(a,o);const p=c[1],u=i[1];p.subVectors(e,t),u.setFromPoints(p,o);const f=c[2],l=i[2];f.subVectors(t,s),l.setFromPoints(f,o);const d=c[3],A=i[3];d.subVectors(s,e),A.setFromPoints(d,o),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,e),this.needsUpdate=!1}}tt.prototype.closestPointToSegment=function(){const n=new D,e=new D,t=new ot;return function(o,c=null,i=null){const{start:a,end:r}=o,p=this.points;let u,f=1/0;for(let l=0;l<3;l++){const d=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[d]),ke(t,o,n,e),u=n.distanceToSquared(e),u<f&&(f=u,c&&c.copy(n),i&&i.copy(e))}return this.closestPointToPoint(a,n),u=a.distanceToSquared(n),u<f&&(f=u,c&&c.copy(n),i&&i.copy(a)),this.closestPointToPoint(r,n),u=r.distanceToSquared(n),u<f&&(f=u,c&&c.copy(n),i&&i.copy(r)),Math.sqrt(f)}}();tt.prototype.intersectsTriangle=function(){const n=new tt,e=new Array(3),t=new Array(3),s=new rt,o=new rt,c=new D,i=new D,a=new D,r=new D,p=new D,u=new ot,f=new ot,l=new ot,d=new D;function A(b,m,h){const y=b.points;let w=0,g=-1;for(let x=0;x<3;x++){const{start:P,end:T}=u;P.copy(y[x]),T.copy(y[(x+1)%3]),u.delta(i);const C=Te(m.distanceToPoint(P));if(Te(m.normal.dot(i))&&C){h.copy(u),w=2;break}const B=m.intersectLine(u,d);if(!B&&C&&d.copy(P),(B||C)&&!Te(d.distanceTo(T))){if(w<=1)(w===1?h.start:h.end).copy(d),C&&(g=w);else if(w>=2){(g===1?h.start:h.end).copy(d),w=2;break}if(w++,w===2&&g===-1)break}}return w}return function(m,h=null,y=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(n.copy(m),n.update(),m=n);const w=this.plane,g=m.plane;if(Math.abs(w.normal.dot(g.normal))>1-1e-10){const x=this.satBounds,P=this.satAxes;t[0]=m.a,t[1]=m.b,t[2]=m.c;for(let B=0;B<4;B++){const _=x[B],S=P[B];if(s.setFromPoints(S,t),_.isSeparated(s))return!1}const T=m.satBounds,C=m.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let B=0;B<4;B++){const _=T[B],S=C[B];if(s.setFromPoints(S,e),_.isSeparated(s))return!1}for(let B=0;B<4;B++){const _=P[B];for(let S=0;S<4;S++){const M=C[S];if(c.crossVectors(_,M),s.setFromPoints(c,e),o.setFromPoints(c,t),s.isSeparated(o))return!1}}return h&&(y||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0)),!0}else{const x=A(this,g,f);if(x===1&&m.containsPoint(f.end))return h&&(h.start.copy(f.end),h.end.copy(f.end)),!0;if(x!==2)return!1;const P=A(m,w,l);if(P===1&&this.containsPoint(l.end))return h&&(h.start.copy(l.end),h.end.copy(l.end)),!0;if(P!==2)return!1;if(f.delta(a),l.delta(r),a.dot(r)<0){let E=l.start;l.start=l.end,l.end=E}const T=f.start.dot(a),C=f.end.dot(a),B=l.start.dot(a),_=l.end.dot(a),S=C<B,M=T<_;return T!==_&&B!==C&&S===M?!1:(h&&(p.subVectors(f.start,l.start),p.dot(a)>0?h.start.copy(f.start):h.start.copy(l.start),p.subVectors(f.end,l.end),p.dot(a)<0?h.end.copy(f.end):h.end.copy(l.end)),!0)}}}();tt.prototype.distanceToPoint=function(){const n=new D;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();tt.prototype.distanceToTriangle=function(){const n=new D,e=new D,t=["a","b","c"],s=new ot,o=new ot;return function(i,a=null,r=null){const p=a||r?s:null;if(this.intersectsTriangle(i,p))return(a||r)&&(a&&p.getCenter(a),r&&p.getCenter(r)),0;let u=1/0;for(let f=0;f<3;f++){let l;const d=t[f],A=i[d];this.closestPointToPoint(A,n),l=A.distanceToSquared(n),l<u&&(u=l,a&&a.copy(n),r&&r.copy(A));const b=this[d];i.closestPointToPoint(b,n),l=b.distanceToSquared(n),l<u&&(u=l,a&&a.copy(b),r&&r.copy(n))}for(let f=0;f<3;f++){const l=t[f],d=t[(f+1)%3];s.set(this[l],this[d]);for(let A=0;A<3;A++){const b=t[A],m=t[(A+1)%3];o.set(i[b],i[m]),ke(s,o,n,e);const h=n.distanceToSquared(e);h<u&&(u=h,a&&a.copy(n),r&&r.copy(e))}}return Math.sqrt(u)}}();class q{constructor(e,t,s){this.isOrientedBox=!0,this.min=new D,this.max=new D,this.matrix=new dt,this.invMatrix=new dt,this.points=new Array(8).fill().map(()=>new D),this.satAxes=new Array(3).fill().map(()=>new D),this.satBounds=new Array(3).fill().map(()=>new rt),this.alignedSatBounds=new Array(3).fill().map(()=>new rt),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(e,t,s){this.min.copy(e),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const e=this.matrix,t=this.min,s=this.max,o=this.points;for(let p=0;p<=1;p++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const l=1*p|2*u|4*f,d=o[l];d.x=p?s.x:t.x,d.y=u?s.y:t.y,d.z=f?s.z:t.z,d.applyMatrix4(e)}const c=this.satBounds,i=this.satAxes,a=o[0];for(let p=0;p<3;p++){const u=i[p],f=c[p],l=1<<p,d=o[l];u.subVectors(a,d),f.setFromPoints(u,o)}const r=this.alignedSatBounds;r[0].setFromPointsField(o,"x"),r[1].setFromPointsField(o,"y"),r[2].setFromPointsField(o,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const n=new rt;return function(t){this.needsUpdate&&this.update();const s=t.min,o=t.max,c=this.satBounds,i=this.satAxes,a=this.alignedSatBounds;if(n.min=s.x,n.max=o.x,a[0].isSeparated(n)||(n.min=s.y,n.max=o.y,a[1].isSeparated(n))||(n.min=s.z,n.max=o.z,a[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const p=i[r],u=c[r];if(n.setFromBox(p,t),u.isSeparated(n))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const n=new tt,e=new Array(3),t=new rt,s=new rt,o=new D;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(n.copy(i),n.update(),i=n);const a=this.satBounds,r=this.satAxes;e[0]=i.a,e[1]=i.b,e[2]=i.c;for(let l=0;l<3;l++){const d=a[l],A=r[l];if(t.setFromPoints(A,e),d.isSeparated(t))return!1}const p=i.satBounds,u=i.satAxes,f=this.points;for(let l=0;l<3;l++){const d=p[l],A=u[l];if(t.setFromPoints(A,f),d.isSeparated(t))return!1}for(let l=0;l<3;l++){const d=r[l];for(let A=0;A<4;A++){const b=u[A];if(o.crossVectors(d,b),t.setFromPoints(o,e),s.setFromPoints(o,f),t.isSeparated(s))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();q.prototype.distanceToPoint=function(){const n=new D;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();q.prototype.distanceToBox=function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new ot),t=new Array(12).fill().map(()=>new ot),s=new D,o=new D;return function(i,a=0,r=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(r||p)&&(i.getCenter(o),this.closestPointToPoint(o,s),i.closestPointToPoint(s,o),r&&r.copy(s),p&&p.copy(o)),0;const u=a*a,f=i.min,l=i.max,d=this.points;let A=1/0;for(let m=0;m<8;m++){const h=d[m];o.copy(h).clamp(f,l);const y=h.distanceToSquared(o);if(y<A&&(A=y,r&&r.copy(h),p&&p.copy(o),y<u))return Math.sqrt(y)}let b=0;for(let m=0;m<3;m++)for(let h=0;h<=1;h++)for(let y=0;y<=1;y++){const w=(m+1)%3,g=(m+2)%3,x=h<<w|y<<g,P=1<<m|h<<w|y<<g,T=d[x],C=d[P];e[b].set(T,C);const _=n[m],S=n[w],M=n[g],E=t[b],R=E.start,L=E.end;R[_]=f[_],R[S]=h?f[S]:l[S],R[M]=y?f[M]:l[S],L[_]=l[_],L[S]=h?f[S]:l[S],L[M]=y?f[M]:l[S],b++}for(let m=0;m<=1;m++)for(let h=0;h<=1;h++)for(let y=0;y<=1;y++){o.x=m?l.x:f.x,o.y=h?l.y:f.y,o.z=y?l.z:f.z,this.closestPointToPoint(o,s);const w=o.distanceToSquared(s);if(w<A&&(A=w,r&&r.copy(s),p&&p.copy(o),w<u))return Math.sqrt(w)}for(let m=0;m<12;m++){const h=e[m];for(let y=0;y<12;y++){const w=t[y];ke(h,w,s,o);const g=s.distanceToSquared(o);if(g<A&&(A=g,r&&r.copy(s),p&&p.copy(o),g<u))return Math.sqrt(g)}}return Math.sqrt(A)}}();class qe{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class ws extends qe{constructor(){super(()=>new tt)}}const O=new ws;class xs{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=s=>{t&&e.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const F=new xs;let pt,Dt;const bt=[],Ot=new qe(()=>new et);function gs(n,e,t,s,o,c){pt=Ot.getPrimitive(),Dt=Ot.getPrimitive(),bt.push(pt,Dt),F.setBuffer(n._roots[e]);const i=De(0,n.geometry,t,s,o,c);F.clearBuffer(),Ot.releasePrimitive(pt),Ot.releasePrimitive(Dt),bt.pop(),bt.pop();const a=bt.length;return a>0&&(Dt=bt[a-1],pt=bt[a-2]),i}function De(n,e,t,s,o=null,c=0,i=0){const{float32Array:a,uint16Array:r,uint32Array:p}=F;let u=n*2;if($(u,r)){const l=Z(n,p),d=G(u,r);return I(n,a,pt),s(l,d,!1,i,c+n,pt)}else{let _=function(M){const{uint16Array:E,uint32Array:R}=F;let L=M*2;for(;!$(L,E);)M=Y(M),L=M*2;return Z(M,R)},S=function(M){const{uint16Array:E,uint32Array:R}=F;let L=M*2;for(;!$(L,E);)M=J(M,R),L=M*2;return Z(M,R)+G(L,E)};const l=Y(n),d=J(n,p);let A=l,b=d,m,h,y,w;if(o&&(y=pt,w=Dt,I(A,a,y),I(b,a,w),m=o(y),h=o(w),h<m)){A=d,b=l;const M=m;m=h,h=M,y=w}y||(y=pt,I(A,a,y));const g=$(A*2,r),x=t(y,g,m,i+1,c+A);let P;if(x===je){const M=_(A),R=S(A)-M;P=s(M,R,!0,i+1,c+A,y)}else P=x&&De(A,e,t,s,o,c,i+1);if(P)return!0;w=Dt,I(b,a,w);const T=$(b*2,r),C=t(w,T,h,i+1,c+b);let B;if(C===je){const M=_(b),R=S(b)-M;B=s(M,R,!0,i+1,c+b,w)}else B=C&&De(b,e,t,s,o,c,i+1);return!!B}}const It=new D,be=new D;function As(n,e,t={},s=0,o=1/0){const c=s*s,i=o*o;let a=1/0,r=null;if(n.shapecast({boundsTraverseOrder:u=>(It.copy(e).clamp(u.min,u.max),It.distanceToSquared(e)),intersectsBounds:(u,f,l)=>l<a&&l<i,intersectsTriangle:(u,f)=>{u.closestPointToPoint(e,It);const l=e.distanceToSquared(It);return l<a&&(be.copy(It),a=l,r=f),l<c}}),a===1/0)return null;const p=Math.sqrt(a);return t.point?t.point.copy(be):t.point=be.clone(),t.distance=p,t.faceIndex=r,t}const Ts=parseInt(Sn)>=169,mt=new D,wt=new D,xt=new D,Kt=new Tt,Qt=new Tt,te=new Tt,Oe=new D,Ke=new D,Qe=new D,Ut=new D;function bs(n,e,t,s,o,c,i,a){let r;if(c===Pn?r=n.intersectTriangle(s,t,e,!0,o):r=n.intersectTriangle(e,t,s,c!==Bn,o),r===null)return null;const p=n.origin.distanceTo(o);return p<i||p>a?null:{distance:p,point:o.clone()}}function Ps(n,e,t,s,o,c,i,a,r,p,u){mt.fromBufferAttribute(e,c),wt.fromBufferAttribute(e,i),xt.fromBufferAttribute(e,a);const f=bs(n,mt,wt,xt,Ut,r,p,u);if(f){const l=new D;Et.getBarycoord(Ut,mt,wt,xt,l),s&&(Kt.fromBufferAttribute(s,c),Qt.fromBufferAttribute(s,i),te.fromBufferAttribute(s,a),f.uv=Et.getInterpolation(Ut,mt,wt,xt,Kt,Qt,te,new Tt)),o&&(Kt.fromBufferAttribute(o,c),Qt.fromBufferAttribute(o,i),te.fromBufferAttribute(o,a),f.uv1=Et.getInterpolation(Ut,mt,wt,xt,Kt,Qt,te,new Tt)),t&&(Oe.fromBufferAttribute(t,c),Ke.fromBufferAttribute(t,i),Qe.fromBufferAttribute(t,a),f.normal=Et.getInterpolation(Ut,mt,wt,xt,Oe,Ke,Qe,new D),f.normal.dot(n.direction)>0&&f.normal.multiplyScalar(-1));const d={a:c,b:i,c:a,normal:new D,materialIndex:0};Et.getNormal(mt,wt,xt,d.normal),f.face=d,f.faceIndex=c,Ts&&(f.barycoord=l)}return f}function he(n,e,t,s,o,c,i){const a=s*3;let r=a+0,p=a+1,u=a+2;const f=n.index;n.index&&(r=f.getX(r),p=f.getX(p),u=f.getX(u));const{position:l,normal:d,uv:A,uv1:b}=n.attributes,m=Ps(t,l,d,A,b,r,p,u,e,c,i);return m?(m.faceIndex=s,o&&o.push(m),m):null}function V(n,e,t,s){const o=n.a,c=n.b,i=n.c;let a=e,r=e+1,p=e+2;t&&(a=t.getX(a),r=t.getX(r),p=t.getX(p)),o.x=s.getX(a),o.y=s.getY(a),o.z=s.getZ(a),c.x=s.getX(r),c.y=s.getY(r),c.z=s.getZ(r),i.x=s.getX(p),i.y=s.getY(p),i.z=s.getZ(p)}function Bs(n,e,t,s,o,c,i,a){const{geometry:r,_indirectBuffer:p}=n;for(let u=s,f=s+o;u<f;u++)he(r,e,t,u,c,i,a)}function Ss(n,e,t,s,o,c,i){const{geometry:a,_indirectBuffer:r}=n;let p=1/0,u=null;for(let f=s,l=s+o;f<l;f++){let d;d=he(a,e,t,f,null,c,i),d&&d.distance<p&&(u=d,p=d.distance)}return u}function Ms(n,e,t,s,o,c,i){const{geometry:a}=t,{index:r}=a,p=a.attributes.position;for(let u=n,f=e+n;u<f;u++){let l;if(l=u,V(i,l*3,r,p),i.needsUpdate=!0,s(i,l,o,c))return!0}return!1}function Cs(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,o=t.attributes.position;let c,i,a,r,p=0;const u=n._roots;for(let l=0,d=u.length;l<d;l++)c=u[l],i=new Uint32Array(c),a=new Uint16Array(c),r=new Float32Array(c),f(0,p),p+=c.byteLength;function f(l,d,A=!1){const b=l*2;if(a[b+15]===ye){const h=i[l+6],y=a[b+14];let w=1/0,g=1/0,x=1/0,P=-1/0,T=-1/0,C=-1/0;for(let B=3*h,_=3*(h+y);B<_;B++){let S=s[B];const M=o.getX(S),E=o.getY(S),R=o.getZ(S);M<w&&(w=M),M>P&&(P=M),E<g&&(g=E),E>T&&(T=E),R<x&&(x=R),R>C&&(C=R)}return r[l+0]!==w||r[l+1]!==g||r[l+2]!==x||r[l+3]!==P||r[l+4]!==T||r[l+5]!==C?(r[l+0]=w,r[l+1]=g,r[l+2]=x,r[l+3]=P,r[l+4]=T,r[l+5]=C,!0):!1}else{const h=l+8,y=i[l+6],w=h+d,g=y+d;let x=A,P=!1,T=!1;e?x||(P=e.has(w),T=e.has(g),x=!P&&!T):(P=!0,T=!0);const C=x||P,B=x||T;let _=!1;C&&(_=f(h,d,x));let S=!1;B&&(S=f(y,d,x));const M=_||S;if(M)for(let E=0;E<3;E++){const R=h+E,L=y+E,U=r[R],ct=r[R+3],Lt=r[L],Ft=r[L+3];r[l+E]=U<Lt?U:Lt,r[l+E+3]=ct>Ft?ct:Ft}return M}}}function yt(n,e,t,s,o){let c,i,a,r,p,u;const f=1/t.direction.x,l=1/t.direction.y,d=1/t.direction.z,A=t.origin.x,b=t.origin.y,m=t.origin.z;let h=e[n],y=e[n+3],w=e[n+1],g=e[n+3+1],x=e[n+2],P=e[n+3+2];return f>=0?(c=(h-A)*f,i=(y-A)*f):(c=(y-A)*f,i=(h-A)*f),l>=0?(a=(w-b)*l,r=(g-b)*l):(a=(g-b)*l,r=(w-b)*l),c>r||a>i||((a>c||isNaN(c))&&(c=a),(r<i||isNaN(i))&&(i=r),d>=0?(p=(x-m)*d,u=(P-m)*d):(p=(P-m)*d,u=(x-m)*d),c>u||p>i)?!1:((p>c||c!==c)&&(c=p),(u<i||i!==i)&&(i=u),c<=o&&i>=s)}function _s(n,e,t,s,o,c,i,a){const{geometry:r,_indirectBuffer:p}=n;for(let u=s,f=s+o;u<f;u++){let l=p?p[u]:u;he(r,e,t,l,c,i,a)}}function Es(n,e,t,s,o,c,i){const{geometry:a,_indirectBuffer:r}=n;let p=1/0,u=null;for(let f=s,l=s+o;f<l;f++){let d;d=he(a,e,t,r?r[f]:f,null,c,i),d&&d.distance<p&&(u=d,p=d.distance)}return u}function Ds(n,e,t,s,o,c,i){const{geometry:a}=t,{index:r}=a,p=a.attributes.position;for(let u=n,f=e+n;u<f;u++){let l;if(l=t.resolveTriangleIndex(u),V(i,l*3,r,p),i.needsUpdate=!0,s(i,l,o,c))return!0}return!1}function Rs(n,e,t,s,o,c,i){F.setBuffer(n._roots[e]),Re(0,n,t,s,o,c,i),F.clearBuffer()}function Re(n,e,t,s,o,c,i){const{float32Array:a,uint16Array:r,uint32Array:p}=F,u=n*2;if($(u,r)){const l=Z(n,p),d=G(u,r);Bs(e,t,s,l,d,o,c,i)}else{const l=Y(n);yt(l,a,s,c,i)&&Re(l,e,t,s,o,c,i);const d=J(n,p);yt(d,a,s,c,i)&&Re(d,e,t,s,o,c,i)}}const Ls=["x","y","z"];function Fs(n,e,t,s,o,c){F.setBuffer(n._roots[e]);const i=Le(0,n,t,s,o,c);return F.clearBuffer(),i}function Le(n,e,t,s,o,c){const{float32Array:i,uint16Array:a,uint32Array:r}=F;let p=n*2;if($(p,a)){const f=Z(n,r),l=G(p,a);return Ss(e,t,s,f,l,o,c)}else{const f=xn(n,r),l=Ls[f],A=s.direction[l]>=0;let b,m;A?(b=Y(n),m=J(n,r)):(b=J(n,r),m=Y(n));const y=yt(b,i,s,o,c)?Le(b,e,t,s,o,c):null;if(y){const x=y.point[l];if(A?x<=i[m+f]:x>=i[m+f+3])return y}const g=yt(m,i,s,o,c)?Le(m,e,t,s,o,c):null;return y&&g?y.distance<=g.distance?y:g:y||g||null}}const ee=new et,Pt=new tt,Bt=new tt,Nt=new dt,tn=new q,ne=new q;function vs(n,e,t,s){F.setBuffer(n._roots[e]);const o=Fe(0,n,t,s);return F.clearBuffer(),o}function Fe(n,e,t,s,o=null){const{float32Array:c,uint16Array:i,uint32Array:a}=F;let r=n*2;if(o===null&&(t.boundingBox||t.computeBoundingBox(),tn.set(t.boundingBox.min,t.boundingBox.max,s),o=tn),$(r,i)){const u=e.geometry,f=u.index,l=u.attributes.position,d=t.index,A=t.attributes.position,b=Z(n,a),m=G(r,i);if(Nt.copy(s).invert(),t.boundsTree)return I(n,c,ne),ne.matrix.copy(Nt),ne.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:y=>ne.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let w=b*3,g=(m+b)*3;w<g;w+=3)if(V(Bt,w,f,l),Bt.needsUpdate=!0,y.intersectsTriangle(Bt))return!0;return!1}});for(let h=b*3,y=(m+b)*3;h<y;h+=3){V(Pt,h,f,l),Pt.a.applyMatrix4(Nt),Pt.b.applyMatrix4(Nt),Pt.c.applyMatrix4(Nt),Pt.needsUpdate=!0;for(let w=0,g=d.count;w<g;w+=3)if(V(Bt,w,d,A),Bt.needsUpdate=!0,Pt.intersectsTriangle(Bt))return!0}}else{const u=n+8,f=a[n+6];return I(u,c,ee),!!(o.intersectsBox(ee)&&Fe(u,e,t,s,o)||(I(f,c,ee),o.intersectsBox(ee)&&Fe(f,e,t,s,o)))}}const se=new dt,Pe=new q,Vt=new q,Is=new D,Us=new D,Ns=new D,Vs=new D;function zs(n,e,t,s={},o={},c=0,i=1/0){e.boundingBox||e.computeBoundingBox(),Pe.set(e.boundingBox.min,e.boundingBox.max,t),Pe.needsUpdate=!0;const a=n.geometry,r=a.attributes.position,p=a.index,u=e.attributes.position,f=e.index,l=O.getPrimitive(),d=O.getPrimitive();let A=Is,b=Us,m=null,h=null;o&&(m=Ns,h=Vs);let y=1/0,w=null,g=null;return se.copy(t).invert(),Vt.matrix.copy(se),n.shapecast({boundsTraverseOrder:x=>Pe.distanceToBox(x),intersectsBounds:(x,P,T)=>T<y&&T<i?(P&&(Vt.min.copy(x.min),Vt.max.copy(x.max),Vt.needsUpdate=!0),!0):!1,intersectsRange:(x,P)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:C=>Vt.distanceToBox(C),intersectsBounds:(C,B,_)=>_<y&&_<i,intersectsRange:(C,B)=>{for(let _=C,S=C+B;_<S;_++){V(d,3*_,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let M=x,E=x+P;M<E;M++){V(l,3*M,p,r),l.needsUpdate=!0;const R=l.distanceToTriangle(d,A,m);if(R<y&&(b.copy(A),h&&h.copy(m),y=R,w=M,g=_),R<c)return!0}}}});{const T=Rt(e);for(let C=0,B=T;C<B;C++){V(d,3*C,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let _=x,S=x+P;_<S;_++){V(l,3*_,p,r),l.needsUpdate=!0;const M=l.distanceToTriangle(d,A,m);if(M<y&&(b.copy(A),h&&h.copy(m),y=M,w=_,g=C),M<c)return!0}}}}}),O.releasePrimitive(l),O.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(b):s.point=b.clone(),s.distance=y,s.faceIndex=w,o&&(o.point?o.point.copy(h):o.point=h.clone(),o.point.applyMatrix4(se),b.applyMatrix4(se),o.distance=b.sub(o.point).length(),o.faceIndex=g),s)}function ks(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,o=t.attributes.position;let c,i,a,r,p=0;const u=n._roots;for(let l=0,d=u.length;l<d;l++)c=u[l],i=new Uint32Array(c),a=new Uint16Array(c),r=new Float32Array(c),f(0,p),p+=c.byteLength;function f(l,d,A=!1){const b=l*2;if(a[b+15]===ye){const h=i[l+6],y=a[b+14];let w=1/0,g=1/0,x=1/0,P=-1/0,T=-1/0,C=-1/0;for(let B=h,_=h+y;B<_;B++){const S=3*n.resolveTriangleIndex(B);for(let M=0;M<3;M++){let E=S+M;E=s?s[E]:E;const R=o.getX(E),L=o.getY(E),U=o.getZ(E);R<w&&(w=R),R>P&&(P=R),L<g&&(g=L),L>T&&(T=L),U<x&&(x=U),U>C&&(C=U)}}return r[l+0]!==w||r[l+1]!==g||r[l+2]!==x||r[l+3]!==P||r[l+4]!==T||r[l+5]!==C?(r[l+0]=w,r[l+1]=g,r[l+2]=x,r[l+3]=P,r[l+4]=T,r[l+5]=C,!0):!1}else{const h=l+8,y=i[l+6],w=h+d,g=y+d;let x=A,P=!1,T=!1;e?x||(P=e.has(w),T=e.has(g),x=!P&&!T):(P=!0,T=!0);const C=x||P,B=x||T;let _=!1;C&&(_=f(h,d,x));let S=!1;B&&(S=f(y,d,x));const M=_||S;if(M)for(let E=0;E<3;E++){const R=h+E,L=y+E,U=r[R],ct=r[R+3],Lt=r[L],Ft=r[L+3];r[l+E]=U<Lt?U:Lt,r[l+E+3]=ct>Ft?ct:Ft}return M}}}function qs(n,e,t,s,o,c,i){F.setBuffer(n._roots[e]),ve(0,n,t,s,o,c,i),F.clearBuffer()}function ve(n,e,t,s,o,c,i){const{float32Array:a,uint16Array:r,uint32Array:p}=F,u=n*2;if($(u,r)){const l=Z(n,p),d=G(u,r);_s(e,t,s,l,d,o,c,i)}else{const l=Y(n);yt(l,a,s,c,i)&&ve(l,e,t,s,o,c,i);const d=J(n,p);yt(d,a,s,c,i)&&ve(d,e,t,s,o,c,i)}}const Hs=["x","y","z"];function $s(n,e,t,s,o,c){F.setBuffer(n._roots[e]);const i=Ie(0,n,t,s,o,c);return F.clearBuffer(),i}function Ie(n,e,t,s,o,c){const{float32Array:i,uint16Array:a,uint32Array:r}=F;let p=n*2;if($(p,a)){const f=Z(n,r),l=G(p,a);return Es(e,t,s,f,l,o,c)}else{const f=xn(n,r),l=Hs[f],A=s.direction[l]>=0;let b,m;A?(b=Y(n),m=J(n,r)):(b=J(n,r),m=Y(n));const y=yt(b,i,s,o,c)?Ie(b,e,t,s,o,c):null;if(y){const x=y.point[l];if(A?x<=i[m+f]:x>=i[m+f+3])return y}const g=yt(m,i,s,o,c)?Ie(m,e,t,s,o,c):null;return y&&g?y.distance<=g.distance?y:g:y||g||null}}const ie=new et,St=new tt,Mt=new tt,zt=new dt,en=new q,oe=new q;function Ws(n,e,t,s){F.setBuffer(n._roots[e]);const o=Ue(0,n,t,s);return F.clearBuffer(),o}function Ue(n,e,t,s,o=null){const{float32Array:c,uint16Array:i,uint32Array:a}=F;let r=n*2;if(o===null&&(t.boundingBox||t.computeBoundingBox(),en.set(t.boundingBox.min,t.boundingBox.max,s),o=en),$(r,i)){const u=e.geometry,f=u.index,l=u.attributes.position,d=t.index,A=t.attributes.position,b=Z(n,a),m=G(r,i);if(zt.copy(s).invert(),t.boundsTree)return I(n,c,oe),oe.matrix.copy(zt),oe.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:y=>oe.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let w=b,g=m+b;w<g;w++)if(V(Mt,3*e.resolveTriangleIndex(w),f,l),Mt.needsUpdate=!0,y.intersectsTriangle(Mt))return!0;return!1}});for(let h=b,y=m+b;h<y;h++){const w=e.resolveTriangleIndex(h);V(St,3*w,f,l),St.a.applyMatrix4(zt),St.b.applyMatrix4(zt),St.c.applyMatrix4(zt),St.needsUpdate=!0;for(let g=0,x=d.count;g<x;g+=3)if(V(Mt,g,d,A),Mt.needsUpdate=!0,St.intersectsTriangle(Mt))return!0}}else{const u=n+8,f=a[n+6];return I(u,c,ie),!!(o.intersectsBox(ie)&&Ue(u,e,t,s,o)||(I(f,c,ie),o.intersectsBox(ie)&&Ue(f,e,t,s,o)))}}const re=new dt,Be=new q,kt=new q,Xs=new D,js=new D,Zs=new D,Gs=new D;function Ys(n,e,t,s={},o={},c=0,i=1/0){e.boundingBox||e.computeBoundingBox(),Be.set(e.boundingBox.min,e.boundingBox.max,t),Be.needsUpdate=!0;const a=n.geometry,r=a.attributes.position,p=a.index,u=e.attributes.position,f=e.index,l=O.getPrimitive(),d=O.getPrimitive();let A=Xs,b=js,m=null,h=null;o&&(m=Zs,h=Gs);let y=1/0,w=null,g=null;return re.copy(t).invert(),kt.matrix.copy(re),n.shapecast({boundsTraverseOrder:x=>Be.distanceToBox(x),intersectsBounds:(x,P,T)=>T<y&&T<i?(P&&(kt.min.copy(x.min),kt.max.copy(x.max),kt.needsUpdate=!0),!0):!1,intersectsRange:(x,P)=>{if(e.boundsTree){const T=e.boundsTree;return T.shapecast({boundsTraverseOrder:C=>kt.distanceToBox(C),intersectsBounds:(C,B,_)=>_<y&&_<i,intersectsRange:(C,B)=>{for(let _=C,S=C+B;_<S;_++){const M=T.resolveTriangleIndex(_);V(d,3*M,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let E=x,R=x+P;E<R;E++){const L=n.resolveTriangleIndex(E);V(l,3*L,p,r),l.needsUpdate=!0;const U=l.distanceToTriangle(d,A,m);if(U<y&&(b.copy(A),h&&h.copy(m),y=U,w=E,g=_),U<c)return!0}}}})}else{const T=Rt(e);for(let C=0,B=T;C<B;C++){V(d,3*C,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let _=x,S=x+P;_<S;_++){const M=n.resolveTriangleIndex(_);V(l,3*M,p,r),l.needsUpdate=!0;const E=l.distanceToTriangle(d,A,m);if(E<y&&(b.copy(A),h&&h.copy(m),y=E,w=_,g=C),E<c)return!0}}}}}),O.releasePrimitive(l),O.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(b):s.point=b.clone(),s.distance=y,s.faceIndex=w,o&&(o.point?o.point.copy(h):o.point=h.clone(),o.point.applyMatrix4(re),b.applyMatrix4(re),o.distance=b.sub(o.point).length(),o.faceIndex=g),s)}function Js(){return typeof SharedArrayBuffer<"u"}const jt=new F.constructor,de=new F.constructor,ft=new qe(()=>new et),Ct=new et,_t=new et,Se=new et,Me=new et;let Ce=!1;function Os(n,e,t,s){if(Ce)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ce=!0;const o=n._roots,c=e._roots;let i,a=0,r=0;const p=new dt().copy(t).invert();for(let u=0,f=o.length;u<f;u++){jt.setBuffer(o[u]),r=0;const l=ft.getPrimitive();I(0,jt.float32Array,l),l.applyMatrix4(p);for(let d=0,A=c.length;d<A&&(de.setBuffer(c[d]),i=K(0,0,t,p,s,a,r,0,0,l),de.clearBuffer(),r+=c[d].length,!i);d++);if(ft.releasePrimitive(l),jt.clearBuffer(),a+=o[u].length,i)break}return Ce=!1,i}function K(n,e,t,s,o,c=0,i=0,a=0,r=0,p=null,u=!1){let f,l;u?(f=de,l=jt):(f=jt,l=de);const d=f.float32Array,A=f.uint32Array,b=f.uint16Array,m=l.float32Array,h=l.uint32Array,y=l.uint16Array,w=n*2,g=e*2,x=$(w,b),P=$(g,y);let T=!1;if(P&&x)u?T=o(Z(e,h),G(e*2,y),Z(n,A),G(n*2,b),r,i+e,a,c+n):T=o(Z(n,A),G(n*2,b),Z(e,h),G(e*2,y),a,c+n,r,i+e);else if(P){const C=ft.getPrimitive();I(e,m,C),C.applyMatrix4(t);const B=Y(n),_=J(n,A);I(B,d,Ct),I(_,d,_t);const S=C.intersectsBox(Ct),M=C.intersectsBox(_t);T=S&&K(e,B,s,t,o,i,c,r,a+1,C,!u)||M&&K(e,_,s,t,o,i,c,r,a+1,C,!u),ft.releasePrimitive(C)}else{const C=Y(e),B=J(e,h);I(C,m,Se),I(B,m,Me);const _=p.intersectsBox(Se),S=p.intersectsBox(Me);if(_&&S)T=K(n,C,t,s,o,c,i,a,r+1,p,u)||K(n,B,t,s,o,c,i,a,r+1,p,u);else if(_)if(x)T=K(n,C,t,s,o,c,i,a,r+1,p,u);else{const M=ft.getPrimitive();M.copy(Se).applyMatrix4(t);const E=Y(n),R=J(n,A);I(E,d,Ct),I(R,d,_t);const L=M.intersectsBox(Ct),U=M.intersectsBox(_t);T=L&&K(C,E,s,t,o,i,c,r,a+1,M,!u)||U&&K(C,R,s,t,o,i,c,r,a+1,M,!u),ft.releasePrimitive(M)}else if(S)if(x)T=K(n,B,t,s,o,c,i,a,r+1,p,u);else{const M=ft.getPrimitive();M.copy(Me).applyMatrix4(t);const E=Y(n),R=J(n,A);I(E,d,Ct),I(R,d,_t);const L=M.intersectsBox(Ct),U=M.intersectsBox(_t);T=L&&K(B,E,s,t,o,i,c,r,a+1,M,!u)||U&&K(B,R,s,t,o,i,c,r,a+1,M,!u),ft.releasePrimitive(M)}}return T}const ce=new q,nn=new et,Ks={strategy:hn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class He{static serialize(e,t={}){t={cloneBuffers:!0,...t};const s=e.geometry,o=e._roots,c=e._indirectBuffer,i=s.getIndex();let a;return t.cloneBuffers?a={roots:o.map(r=>r.slice()),index:i?i.array.slice():null,indirectBuffer:c?c.slice():null}:a={roots:o,index:i?i.array:null,indirectBuffer:c},a}static deserialize(e,t,s={}){s={setIndex:!0,indirect:!!e.indirectBuffer,...s};const{index:o,roots:c,indirectBuffer:i}=e,a=new He(t,{...s,[xe]:!0});if(a._roots=c,a._indirectBuffer=i||null,s.setIndex){const r=t.getIndex();if(r===null){const p=new un(e.index,1,!1);t.setIndex(p)}else r.array!==o&&(r.array.set(o),r.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...Ks,[xe]:!1},t),t.useSharedArrayBuffer&&!Js())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[xe]||(ds(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new et))),this.resolveTriangleIndex=t.indirect?s=>this._indirectBuffer[s]:s=>s}refit(e=null){return(this.indirect?ks:Cs)(this,e)}traverse(e,t=0){const s=this._roots[t],o=new Uint32Array(s),c=new Uint16Array(s);i(0);function i(a,r=0){const p=a*2,u=c[p+15]===ye;if(u){const f=o[a+6],l=c[p+14];e(r,u,new Float32Array(s,a*4,6),f,l)}else{const f=a+Xt/4,l=o[a+6],d=o[a+7];e(r,u,new Float32Array(s,a*4,6),d)||(i(f,r+1),i(l,r+1))}}}raycast(e,t=$e,s=0,o=1/0){const c=this._roots,i=this.geometry,a=[],r=t.isMaterial,p=Array.isArray(t),u=i.groups,f=r?t.side:t,l=this.indirect?qs:Rs;for(let d=0,A=c.length;d<A;d++){const b=p?t[u[d].materialIndex].side:f,m=a.length;if(l(this,d,b,e,a,s,o),p){const h=u[d].materialIndex;for(let y=m,w=a.length;y<w;y++)a[y].face.materialIndex=h}}return a}raycastFirst(e,t=$e,s=0,o=1/0){const c=this._roots,i=this.geometry,a=t.isMaterial,r=Array.isArray(t);let p=null;const u=i.groups,f=a?t.side:t,l=this.indirect?$s:Fs;for(let d=0,A=c.length;d<A;d++){const b=r?t[u[d].materialIndex].side:f,m=l(this,d,b,e,s,o);m!=null&&(p==null||m.distance<p.distance)&&(p=m,r&&(m.face.materialIndex=u[d].materialIndex))}return p}intersectsGeometry(e,t){let s=!1;const o=this._roots,c=this.indirect?Ws:vs;for(let i=0,a=o.length;i<a&&(s=c(this,i,e,t),!s);i++);return s}shapecast(e){const t=O.getPrimitive(),s=this.indirect?Ds:Ms;let{boundsTraverseOrder:o,intersectsBounds:c,intersectsRange:i,intersectsTriangle:a}=e;if(i&&a){const f=i;i=(l,d,A,b,m)=>f(l,d,A,b,m)?!0:s(l,d,this,a,A,b,t)}else i||(a?i=(f,l,d,A)=>s(f,l,this,a,d,A,t):i=(f,l,d)=>d);let r=!1,p=0;const u=this._roots;for(let f=0,l=u.length;f<l;f++){const d=u[f];if(r=gs(this,f,c,i,o,p),r)break;p+=d.byteLength}return O.releasePrimitive(t),r}bvhcast(e,t,s){let{intersectsRanges:o,intersectsTriangles:c}=s;const i=O.getPrimitive(),a=this.geometry.index,r=this.geometry.attributes.position,p=this.indirect?A=>{const b=this.resolveTriangleIndex(A);V(i,b*3,a,r)}:A=>{V(i,A*3,a,r)},u=O.getPrimitive(),f=e.geometry.index,l=e.geometry.attributes.position,d=e.indirect?A=>{const b=e.resolveTriangleIndex(A);V(u,b*3,f,l)}:A=>{V(u,A*3,f,l)};if(c){const A=(b,m,h,y,w,g,x,P)=>{for(let T=h,C=h+y;T<C;T++){d(T),u.a.applyMatrix4(t),u.b.applyMatrix4(t),u.c.applyMatrix4(t),u.needsUpdate=!0;for(let B=b,_=b+m;B<_;B++)if(p(B),i.needsUpdate=!0,c(i,u,B,T,w,g,x,P))return!0}return!1};if(o){const b=o;o=function(m,h,y,w,g,x,P,T){return b(m,h,y,w,g,x,P,T)?!0:A(m,h,y,w,g,x,P,T)}}else o=A}return Os(this,e,t,o)}intersectsBox(e,t){return ce.set(e.min,e.max,t),ce.needsUpdate=!0,this.shapecast({intersectsBounds:s=>ce.intersectsBox(s),intersectsTriangle:s=>ce.intersectsTriangle(s)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,s={},o={},c=0,i=1/0){return(this.indirect?Ys:zs)(this,e,t,s,o,c,i)}closestPointToPoint(e,t={},s=0,o=1/0){return As(this,e,t,s,o)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(s=>{I(0,new Float32Array(s),nn),e.union(nn)}),e}}function sn(n,e,t){return n===null?null:(n.point.applyMatrix4(e.matrixWorld),n.distance=n.point.distanceTo(t.ray.origin),n.object=e,n)}const ae=new Cn,on=new D,rn=new dt,Qs=Gt.prototype.raycast,ti=Mn.prototype.raycast,cn=new D,z=new Gt,le=[];function ei(n,e){this.isBatchedMesh?ni.call(this,n,e):si.call(this,n,e)}function ni(n,e){if(this.boundsTrees){const t=this.boundsTrees,s=this._drawInfo||this._instanceInfo,o=this._drawRanges||this._geometryInfo,c=this.matrixWorld;z.material=this.material,z.geometry=this.geometry;const i=z.geometry.boundsTree,a=z.geometry.drawRange;z.geometry.boundingSphere===null&&(z.geometry.boundingSphere=new pn);for(let r=0,p=s.length;r<p;r++){if(!this.getVisibleAt(r))continue;const u=s[r].geometryIndex;if(z.geometry.boundsTree=t[u],this.getMatrixAt(r,z.matrixWorld).premultiply(c),!z.geometry.boundsTree){this.getBoundingBoxAt(u,z.geometry.boundingBox),this.getBoundingSphereAt(u,z.geometry.boundingSphere);const f=o[u];z.geometry.setDrawRange(f.start,f.count)}z.raycast(n,le);for(let f=0,l=le.length;f<l;f++){const d=le[f];d.object=this,d.batchId=r,e.push(d)}le.length=0}z.geometry.boundsTree=i,z.geometry.drawRange=a,z.material=null,z.geometry=null}else ti.call(this,n,e)}function si(n,e){if(this.geometry.boundsTree){if(this.material===void 0)return;rn.copy(this.matrixWorld).invert(),ae.copy(n.ray).applyMatrix4(rn),cn.setFromMatrixScale(this.matrixWorld),on.copy(ae.direction).multiply(cn);const t=on.length(),s=n.near/t,o=n.far/t,c=this.geometry.boundsTree;if(n.firstHitOnly===!0){const i=sn(c.raycastFirst(ae,this.material,s,o),this,n);i&&e.push(i)}else{const i=c.raycast(ae,this.material,s,o);for(let a=0,r=i.length;a<r;a++){const p=sn(i[a],this,n);p&&e.push(p)}}}else Qs.call(this,n,e)}function ii(n={}){return this.boundsTree=new He(this,n),this.boundsTree}function oi(){this.boundsTree=null}Gt.prototype.raycast=ei;dn.prototype.computeBoundsTree=ii;dn.prototype.disposeBoundsTree=oi;const k={solve:!0,displayMesh:!0,displayIk:!1,enableControls:!0,terrainHeight:.35,settleIterations:10},ri={maxIterations:10,divergeThreshold:.05,stallThreshold:1e-4,translationErrorClamp:1,rotationErrorClamp:.25};let gt,Ne,Tn,Q,st,At,Ve,qt,H,N,it,X,Zt=!0;const an=new Tt,ln=new D,ue=new _n,Ht=new Float64Array(3);let j,v,pe,Wt,ze;ci();bn();function ci(){Ne=new Hn,document.body.appendChild(Ne.dom),Tn=document.getElementById("output"),Q=new En({antialias:!0}),Q.setPixelRatio(window.devicePixelRatio),Q.setSize(window.innerWidth,window.innerHeight),Q.shadowMap.enabled=!0,Q.shadowMap.type=Dn,document.body.appendChild(Q.domElement),At=new Rn(50,window.innerWidth/window.innerHeight),At.position.set(8,8,8),st=new Ln,st.background=new Fn(1971741),X=new vn,X.position.set(1,3,2),X.intensity=3*.75,X.castShadow=!0,X.shadow.normalBias=1e-4,X.shadow.mapSize.setScalar(1024);const n=X.shadow.camera;n.top=n.right=2,n.left=n.bottom=-2,n.updateProjectionMatrix(),st.add(X,X.target);const e=new In(2038302,3);st.add(e),qt=new $n(At,Q.domElement),H=new Wn(At,Q.domElement),H.setSpace("local"),st.add(H.getHelper()),H.addEventListener("mouseDown",()=>qt.enabled=!1),H.addEventListener("mouseUp",()=>qt.enabled=!0),N=new Un,N.position.set(0,0,0),N.rotation.set(Math.PI/2,0,0),st.add(N),H.attach(N),H.addEventListener("objectChange",()=>{Zt=!0});const t=400;it=new Gt(new Nn(25,25,t,t),new Vn);const s=it.geometry.attributes.position;for(let c=0;c<=t+1;c++)for(let i=0;i<=t+1;i++){const a=t*c+i,r=s.getX(a)*1.5,p=s.getY(a)*1.5;s.setZ(a,Math.min(Math.abs(Math.sin(p)),Math.abs(Math.sin(r))))}it.rotation.set(-Math.PI/2,0,0),it.geometry.computeVertexNormals(),it.receiveShadow=!0,it.geometry.computeBoundsTree(),st.add(it),gt=new zn,gt.add(k,"enableControls"),gt.add(k,"solve"),gt.add(k,"displayMesh"),gt.add(k,"displayIk"),gt.add(k,"settleIterations").min(1).max(20).step(1).onChange(()=>Zt=!0),gt.add(k,"terrainHeight",.05,.7).onChange(()=>Zt=!0);const o=new Xn;o.fetchOptions={mode:"cors"},o.loadMeshCb=(c,i,a)=>{/\.glb$/.test(c)||/\.gltf$/.test(c)?new Yn(i).load(c,r=>{r.scene.traverse(p=>{p.castShadow=!0,p.receiveShadow=!0,p.geometry&&!p.geometry.attributes.normals&&p.geometry.computeVertexNormals()}),a(r.scene)}):/\.stl$/.test(c)&&new jn(i).load(c,r=>{const p=new Gt(r);p.castShadow=!0,p.receiveShadow=!0,a(p)})},o.loadAsync("https://raw.githubusercontent.com/gkjohnson/m2020-urdf-models/main/rover/m2020.urdf").then(c=>{c.traverse(S=>{S.jointType==="floating"&&(S.jointType="fixed")}),j=c,v=Zn(j,!0);const i=v.find(S=>S.name==="CENTER_DIFFERENTIAL").child;i.removeChild(i.children[0]);const a=v.find(S=>S.name==="LEFT_DIFFERENTIAL").child,r=new at;i.addChild(r);const p=new lt;p.setPosition(0,-.7,0),r.addChild(p);const u=new at;u.setDoF(W.EZ),p.addChild(u);const f=new lt;f.setPosition(0,0,0),u.addChild(f);const l=new at;l.setDoF(W.EY),f.addChild(l);const d=new lt;a.getWorldPosition(d.position),d.setMatrixNeedsUpdate(),l.attachChild(d),d.position[1]=0,d.position[2]=0,d.setMatrixNeedsUpdate();const A=new at;a.addChild(A);const b=new lt;d.getWorldPosition(b.position),d.getWorldQuaternion(b.quaternion),b.setMatrixNeedsUpdate(),A.attachChild(b);const m=new me;m.setFreeDoF(W.EX,W.EY,W.EZ),b.addChild(m),m.makeClosure(d);const h=v.find(S=>S.name==="RIGHT_DIFFERENTIAL").child,y=new at;i.addChild(y);const w=new lt;w.setPosition(0,.7,0),y.addChild(w);const g=new at;g.setDoF(W.EZ),w.addChild(g);const x=new lt;x.setPosition(0,0,0),g.addChild(x);const P=new at;P.setDoF(W.EY),x.addChild(P);const T=new lt;h.getWorldPosition(T.position),T.setMatrixNeedsUpdate(),P.attachChild(T),T.position[1]=0,T.position[2]=0,T.setMatrixNeedsUpdate();const C=new at;h.addChild(C);const B=new lt;T.getWorldPosition(B.position),T.getWorldQuaternion(B.quaternion),B.setMatrixNeedsUpdate(),C.attachChild(B);const _=new me;_.setFreeDoF(W.EX,W.EY,W.EZ),B.addChild(_),_.makeClosure(T),pe=new We([v]),pe.setColor(15277667),Wt=new We([v]),Wt.setColor(15277667),Wt.setDrawThrough(!0),j.rotation.set(Math.PI/2,0,0),Gn(v,j),Ve=["LR_DRIVE","LM_DRIVE","LF_DRIVE","RR_DRIVE","RM_DRIVE","RF_DRIVE"].map(S=>{const M=new me;return M.setGoalDoF(W.X,W.Y,W.Z),v.traverse(E=>{if(E.name===S){const R=E.child;R.getWorldPosition(M.position),M.setMatrixWorldNeedsUpdate(),M.makeClosure(R)}}),M}),v.traverse(S=>{switch(S.name){case"JOINT1_ENC":S.setTargetValues(90*ht.DEG2RAD),S.targetSet=!0;break;case"JOINT2_ENC":S.setTargetValues(-18*ht.DEG2RAD),S.targetSet=!0;break;case"JOINT3_ENC":S.setTargetValues(-160*ht.DEG2RAD),S.targetSet=!0;break;case"JOINT4_ENC":S.setTargetValues(178*ht.DEG2RAD),S.targetSet=!0;break;case"JOINT5_ENC":S.setTargetValues(90*ht.DEG2RAD),S.targetSet=!0;break;case"RSM_AZ_ENC":S.setTargetValues(180*ht.DEG2RAD),S.targetSet=!0;break;case"RSM_EL_ENC":S.setTargetValues(90*ht.DEG2RAD),S.targetSet=!0;break}}),ze=new kn([v,...Ve]),st.add(j,pe,Wt)}),window.addEventListener("resize",()=>{const c=window.innerWidth,i=window.innerHeight,a=c/i;Q.setSize(c,i),At.aspect=a,At.updateProjectionMatrix()}),window.addEventListener("keydown",c=>{switch(c.key){case"w":H.setMode("translate");break;case"e":H.setMode("rotate");break;case"q":H.setSpace(H.space==="local"?"world":"local");break;case"f":qt.target.set(0,0,0),qt.update();break}}),Q.domElement.addEventListener("pointerdown",c=>{an.x=c.clientX,an.y=c.clientY})}function ai(){v.setPosition(N.position.x,v.position[1],N.position.z),v.setQuaternion(N.quaternion.x,N.quaternion.y,N.quaternion.z,N.quaternion.w),v.traverse(t=>{t.isJoint&&(t.dofValues.fill(0),t.setMatrixDoFNeedsUpdate())});let n="",e=0;for(let t=0;t<k.settleIterations;t++){v.updateMatrixWorld(!0),Ve.forEach((r,p)=>{r.child.getWorldPosition(Ht),ue.ray.origin.set(Ht[0],3,Ht[2]),ue.ray.direction.set(0,-1,0),ue.firstHitOnly=!0;let f=0;const l=ue.intersectObject(it,!0);l.length&&(f=l[0].point.y+.25),r.setPosition(Ht[0],f,Ht[2])}),Object.assign(ze,ri);const s=window.performance.now(),o=ze.solve(),c=window.performance.now()-s;e+=c,n+=c.toFixed(2)+"ms "+qn[o[0]]+`
`;const i=o.filter(r=>r===Xe.CONVERGED).length===o.length,a=o.filter(r=>r===Xe.DIVERGED).length===o.length;if(i||a)break}n=n+`
Total: `+e.toFixed(2)+"ms",Tn.textContent=n,yn(j,v)}function bn(){requestAnimationFrame(bn),it.scale.z=k.terrainHeight,j&&(Zt&&k.solve?(ai(),Zt=!1):k.solve||(v.setPosition(N.position.x,N.position.y,N.position.z),v.setQuaternion(N.quaternion.x,N.quaternion.y,N.quaternion.z,N.quaternion.w),yn(j,v))),j&&(j.visible=k.displayMesh,pe.visible=k.displayIk,Wt.visible=k.displayIk),v&&!H.dragging&&(N.position.set(...v.position),N.quaternion.set(...v.quaternion)),j&&(ln.subVectors(X.position,X.target.position),X.target.position.copy(j.position),X.position.copy(j.position).add(ln)),H.visible=k.enableControls,H.enabled=k.enableControls,Q.render(st,At),Ne.update()}
