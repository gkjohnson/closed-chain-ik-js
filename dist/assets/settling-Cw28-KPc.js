import{l as un,V as L,m as fn,n as ot,h as Tt,T as Et,i as pn,o as dt,B as et,p as Pn,q as Bn,r as Sn,F as $e,M as Yt,s as Mn,t as Cn,u as dn,R as _n,W as En,e as Ln,P as Fn,S as Rn,C as Dn,D as vn,A as Un,G as In,v as Nn,w as Vn,g as zn,J as at,L as lt,a as W,b as me,I as We,x as ht,c as kn,d as qn,f as Xe}from"./IKRootsHelper-COUPCDCE.js";import{S as Hn,O as $n,T as Wn}from"./stats.module-BmaK_bvY.js";import{U as Xn,S as jn,u as Zn,s as Yn,a as yn}from"./URDFLoader-BGE-E6rN.js";import{G as Gn}from"./GLTFLoader-B1LzBeNl.js";const hn=0,Jn=1,On=2,je=2,we=1.25,Ze=1,Xt=32,ye=65535,Kn=Math.pow(2,-24),xe=Symbol("SKIP_GENERATION");function Qn(n){return n.index?n.index.count:n.attributes.position.count}function Ft(n){return Qn(n)/3}function ts(n,e=ArrayBuffer){return n>65535?new Uint32Array(new e(4*n)):new Uint16Array(new e(2*n))}function es(n,e){if(!n.index){const t=n.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=ts(t,s);n.setIndex(new un(o,1));for(let a=0;a<t;a++)o[a]=a}}function mn(n,e){const t=Ft(n),s=e||n.drawRange,o=s.start/3,a=(s.start+s.count)/3,i=Math.max(0,o),c=Math.min(t,a)-i;return[{offset:Math.floor(i),count:Math.floor(c)}]}function wn(n,e){if(!n.groups||!n.groups.length)return mn(n,e);const t=[],s=new Set,o=e||n.drawRange,a=o.start/3,i=(o.start+o.count)/3;for(const r of n.groups){const p=r.start/3,u=(r.start+r.count)/3;s.add(Math.max(a,p)),s.add(Math.min(i,u))}const c=Array.from(s.values()).sort((r,p)=>r-p);for(let r=0;r<c.length-1;r++){const p=c[r],u=c[r+1];t.push({offset:Math.floor(p),count:Math.floor(u-p)})}return t}function ns(n,e){const t=Ft(n),s=wn(n,e).sort((i,c)=>i.offset-c.offset),o=s[s.length-1];o.count=Math.min(t-o.offset,o.count);let a=0;return s.forEach(({count:i})=>a+=i),t!==a}function ge(n,e,t,s,o){let a=1/0,i=1/0,c=1/0,r=-1/0,p=-1/0,u=-1/0,f=1/0,l=1/0,d=1/0,A=-1/0,b=-1/0,m=-1/0;for(let h=e*6,y=(e+t)*6;h<y;h+=6){const w=n[h+0],g=n[h+1],x=w-g,P=w+g;x<a&&(a=x),P>r&&(r=P),w<f&&(f=w),w>A&&(A=w);const T=n[h+2],C=n[h+3],B=T-C,_=T+C;B<i&&(i=B),_>p&&(p=_),T<l&&(l=T),T>b&&(b=T);const S=n[h+4],M=n[h+5],E=S-M,F=S+M;E<c&&(c=E),F>u&&(u=F),S<d&&(d=S),S>m&&(m=S)}s[0]=a,s[1]=i,s[2]=c,s[3]=r,s[4]=p,s[5]=u,o[0]=f,o[1]=l,o[2]=d,o[3]=A,o[4]=b,o[5]=m}function ss(n,e=null,t=null,s=null){const o=n.attributes.position,a=n.index?n.index.array:null,i=Ft(n),c=o.normalized;let r;e===null?(r=new Float32Array(i*6),t=0,s=i):(r=e,t=t||0,s=s||i);const p=o.array,u=o.offset||0;let f=3;o.isInterleavedBufferAttribute&&(f=o.data.stride);const l=["getX","getY","getZ"];for(let d=t;d<t+s;d++){const A=d*3,b=d*6;let m=A+0,h=A+1,y=A+2;a&&(m=a[m],h=a[h],y=a[y]),c||(m=m*f+u,h=h*f+u,y=y*f+u);for(let w=0;w<3;w++){let g,x,P;c?(g=o[l[w]](m),x=o[l[w]](h),P=o[l[w]](y)):(g=p[m+w],x=p[h+w],P=p[y+w]);let T=g;x<T&&(T=x),P<T&&(T=P);let C=g;x>C&&(C=x),P>C&&(C=P);const B=(C-T)/2,_=w*2;r[b+_+0]=T+B,r[b+_+1]=B+(Math.abs(T)+B)*Kn}}return r}function U(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}function Ye(n){let e=-1,t=-1/0;for(let s=0;s<3;s++){const o=n[s+3]-n[s];o>t&&(t=o,e=s)}return e}function Ge(n,e){e.set(n)}function Je(n,e,t){let s,o;for(let a=0;a<3;a++){const i=a+3;s=n[a],o=e[a],t[a]=s<o?s:o,s=n[i],o=e[i],t[i]=s>o?s:o}}function Gt(n,e,t){for(let s=0;s<3;s++){const o=e[n+2*s],a=e[n+2*s+1],i=o-a,c=o+a;i<t[s]&&(t[s]=i),c>t[s+3]&&(t[s+3]=c)}}function vt(n){const e=n[3]-n[0],t=n[4]-n[1],s=n[5]-n[2];return 2*(e*t+t*s+s*e)}const nt=32,is=(n,e)=>n.candidate-e.candidate,ut=new Array(nt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Jt=new Float32Array(6);function os(n,e,t,s,o,a){let i=-1,c=0;if(a===hn)i=Ye(e),i!==-1&&(c=(e[i]+e[i+3])/2);else if(a===Jn)i=Ye(n),i!==-1&&(c=rs(t,s,o,i));else if(a===On){const r=vt(n);let p=we*o;const u=s*6,f=(s+o)*6;for(let l=0;l<3;l++){const d=e[l],m=(e[l+3]-d)/nt;if(o<nt/4){const h=[...ut];h.length=o;let y=0;for(let g=u;g<f;g+=6,y++){const x=h[y];x.candidate=t[g+2*l],x.count=0;const{bounds:P,leftCacheBounds:T,rightCacheBounds:C}=x;for(let B=0;B<3;B++)C[B]=1/0,C[B+3]=-1/0,T[B]=1/0,T[B+3]=-1/0,P[B]=1/0,P[B+3]=-1/0;Gt(g,t,P)}h.sort(is);let w=o;for(let g=0;g<w;g++){const x=h[g];for(;g+1<w&&h[g+1].candidate===x.candidate;)h.splice(g+1,1),w--}for(let g=u;g<f;g+=6){const x=t[g+2*l];for(let P=0;P<w;P++){const T=h[P];x>=T.candidate?Gt(g,t,T.rightCacheBounds):(Gt(g,t,T.leftCacheBounds),T.count++)}}for(let g=0;g<w;g++){const x=h[g],P=x.count,T=o-x.count,C=x.leftCacheBounds,B=x.rightCacheBounds;let _=0;P!==0&&(_=vt(C)/r);let S=0;T!==0&&(S=vt(B)/r);const M=Ze+we*(_*P+S*T);M<p&&(i=l,p=M,c=x.candidate)}}else{for(let w=0;w<nt;w++){const g=ut[w];g.count=0,g.candidate=d+m+w*m;const x=g.bounds;for(let P=0;P<3;P++)x[P]=1/0,x[P+3]=-1/0}for(let w=u;w<f;w+=6){let P=~~((t[w+2*l]-d)/m);P>=nt&&(P=nt-1);const T=ut[P];T.count++,Gt(w,t,T.bounds)}const h=ut[nt-1];Ge(h.bounds,h.rightCacheBounds);for(let w=nt-2;w>=0;w--){const g=ut[w],x=ut[w+1];Je(g.bounds,x.rightCacheBounds,g.rightCacheBounds)}let y=0;for(let w=0;w<nt-1;w++){const g=ut[w],x=g.count,P=g.bounds,C=ut[w+1].rightCacheBounds;x!==0&&(y===0?Ge(P,Jt):Je(P,Jt,Jt)),y+=x;let B=0,_=0;y!==0&&(B=vt(Jt)/r);const S=o-y;S!==0&&(_=vt(C)/r);const M=Ze+we*(B*y+_*S);M<p&&(i=l,p=M,c=g.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:i,pos:c}}function rs(n,e,t,s){let o=0;for(let a=e,i=e+t;a<i;a++)o+=n[a*6+s*2];return o/t}class Ae{constructor(){this.boundingData=new Float32Array(6)}}function cs(n,e,t,s,o,a){let i=s,c=s+o-1;const r=a.pos,p=a.axis*2;for(;;){for(;i<=c&&t[i*6+p]<r;)i++;for(;i<=c&&t[c*6+p]>=r;)c--;if(i<c){for(let u=0;u<3;u++){let f=e[i*3+u];e[i*3+u]=e[c*3+u],e[c*3+u]=f}for(let u=0;u<6;u++){let f=t[i*6+u];t[i*6+u]=t[c*6+u],t[c*6+u]=f}i++,c--}else return i}}function as(n,e,t,s,o,a){let i=s,c=s+o-1;const r=a.pos,p=a.axis*2;for(;;){for(;i<=c&&t[i*6+p]<r;)i++;for(;i<=c&&t[c*6+p]>=r;)c--;if(i<c){let u=n[i];n[i]=n[c],n[c]=u;for(let f=0;f<6;f++){let l=t[i*6+f];t[i*6+f]=t[c*6+f],t[c*6+f]=l}i++,c--}else return i}}function $(n,e){return e[n+15]===65535}function Z(n,e){return e[n+6]}function Y(n,e){return e[n+14]}function G(n){return n+8}function J(n,e){return e[n+6]}function xn(n,e){return e[n+7]}let gn,$t,fe,An;const ls=Math.pow(2,32);function _e(n){return"count"in n?1:1+_e(n.left)+_e(n.right)}function us(n,e,t){return gn=new Float32Array(t),$t=new Uint32Array(t),fe=new Uint16Array(t),An=new Uint8Array(t),Ee(n,e)}function Ee(n,e){const t=n/4,s=n/2,o="count"in e,a=e.boundingData;for(let i=0;i<6;i++)gn[t+i]=a[i];if(o)if(e.buffer){const i=e.buffer;An.set(new Uint8Array(i),n);for(let c=n,r=n+i.byteLength;c<r;c+=Xt){const p=c/2;$(p,fe)||($t[c/4+6]+=t)}return n+i.byteLength}else{const i=e.offset,c=e.count;return $t[t+6]=i,fe[s+14]=c,fe[s+15]=ye,n+Xt}else{const i=e.left,c=e.right,r=e.splitAxis;let p;if(p=Ee(n+Xt,i),p/4>ls)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return $t[t+6]=p/4,p=Ee(p,c),$t[t+7]=r,p}}function fs(n,e){const t=(n.index?n.index.count:n.attributes.position.count)/3,s=t>2**16,o=s?4:2,a=e?new SharedArrayBuffer(t*o):new ArrayBuffer(t*o),i=s?new Uint32Array(a):new Uint16Array(a);for(let c=0,r=i.length;c<r;c++)i[c]=c;return i}function ps(n,e,t,s,o){const{maxDepth:a,verbose:i,maxLeafTris:c,strategy:r,onProgress:p,indirect:u}=o,f=n._indirectBuffer,l=n.geometry,d=l.index?l.index.array:null,A=u?as:cs,b=Ft(l),m=new Float32Array(6);let h=!1;const y=new Ae;return ge(e,t,s,y.boundingData,m),g(y,t,s,m),y;function w(x){p&&p(x/b)}function g(x,P,T,C=null,B=0){if(!h&&B>=a&&(h=!0,i&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(l))),T<=c||B>=a)return w(P+T),x.offset=P,x.count=T,x;const _=os(x.boundingData,C,e,P,T,r);if(_.axis===-1)return w(P+T),x.offset=P,x.count=T,x;const S=A(f,d,e,P,T,_);if(S===P||S===P+T)w(P+T),x.offset=P,x.count=T;else{x.splitAxis=_.axis;const M=new Ae,E=P,F=S-P;x.left=M,ge(e,E,F,M.boundingData,m),g(M,E,F,m,B+1);const R=new Ae,I=S,ct=T-F;x.right=R,ge(e,I,ct,R.boundingData,m),g(R,I,ct,m,B+1)}return x}}function ds(n,e){const t=n.geometry;e.indirect&&(n._indirectBuffer=fs(t,e.useSharedArrayBuffer),ns(t,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||es(t,e);const s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=ss(t),a=e.indirect?mn(t,e.range):wn(t,e.range);n._roots=a.map(i=>{const c=ps(n,o,i.offset,i.count,e),r=_e(c),p=new s(Xt*r);return us(0,c,p),p})}class rt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let s=1/0,o=-1/0;for(let a=0,i=e.length;a<i;a++){const r=e[a][t];s=r<s?r:s,o=r>o?r:o}this.min=s,this.max=o}setFromPoints(e,t){let s=1/0,o=-1/0;for(let a=0,i=t.length;a<i;a++){const c=t[a],r=e.dot(c);s=r<s?r:s,o=r>o?r:o}this.min=s,this.max=o}isSeparated(e){return this.min>e.max||e.min>this.max}}rt.prototype.setFromBox=(function(){const n=new L;return function(t,s){const o=s.min,a=s.max;let i=1/0,c=-1/0;for(let r=0;r<=1;r++)for(let p=0;p<=1;p++)for(let u=0;u<=1;u++){n.x=o.x*r+a.x*(1-r),n.y=o.y*p+a.y*(1-p),n.z=o.z*u+a.z*(1-u);const f=t.dot(n);i=Math.min(f,i),c=Math.max(f,c)}this.min=i,this.max=c}})();const ys=(function(){const n=new L,e=new L,t=new L;return function(o,a,i){const c=o.start,r=n,p=a.start,u=e;t.subVectors(c,p),n.subVectors(o.end,o.start),e.subVectors(a.end,a.start);const f=t.dot(u),l=u.dot(r),d=u.dot(u),A=t.dot(r),m=r.dot(r)*d-l*l;let h,y;m!==0?h=(f*l-A*d)/m:h=0,y=(f+h*l)/d,i.x=h,i.y=y}})(),ke=(function(){const n=new Tt,e=new L,t=new L;return function(o,a,i,c){ys(o,a,n);let r=n.x,p=n.y;if(r>=0&&r<=1&&p>=0&&p<=1){o.at(r,i),a.at(p,c);return}else if(r>=0&&r<=1){p<0?a.at(0,c):a.at(1,c),o.closestPointToPoint(c,!0,i);return}else if(p>=0&&p<=1){r<0?o.at(0,i):o.at(1,i),a.closestPointToPoint(i,!0,c);return}else{let u;r<0?u=o.start:u=o.end;let f;p<0?f=a.start:f=a.end;const l=e,d=t;if(o.closestPointToPoint(f,!0,e),a.closestPointToPoint(u,!0,t),l.distanceToSquared(f)<=d.distanceToSquared(u)){i.copy(l),c.copy(f);return}else{i.copy(u),c.copy(d);return}}}})(),hs=(function(){const n=new L,e=new L,t=new fn,s=new ot;return function(a,i){const{radius:c,center:r}=a,{a:p,b:u,c:f}=i;if(s.start=p,s.end=u,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c||(s.start=p,s.end=f,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c)||(s.start=u,s.end=f,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c))return!0;const b=i.getPlane(t);if(Math.abs(b.distanceToPoint(r))<=c){const h=b.projectPoint(r,e);if(i.containsPoint(h))return!0}return!1}})(),ms=1e-15;function Te(n){return Math.abs(n)<ms}class tt extends Et{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new rt),this.points=[this.a,this.b,this.c],this.sphere=new pn,this.plane=new fn,this.needsUpdate=!0}intersectsSphere(e){return hs(e,this)}update(){const e=this.a,t=this.b,s=this.c,o=this.points,a=this.satAxes,i=this.satBounds,c=a[0],r=i[0];this.getNormal(c),r.setFromPoints(c,o);const p=a[1],u=i[1];p.subVectors(e,t),u.setFromPoints(p,o);const f=a[2],l=i[2];f.subVectors(t,s),l.setFromPoints(f,o);const d=a[3],A=i[3];d.subVectors(s,e),A.setFromPoints(d,o),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,e),this.needsUpdate=!1}}tt.prototype.closestPointToSegment=(function(){const n=new L,e=new L,t=new ot;return function(o,a=null,i=null){const{start:c,end:r}=o,p=this.points;let u,f=1/0;for(let l=0;l<3;l++){const d=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[d]),ke(t,o,n,e),u=n.distanceToSquared(e),u<f&&(f=u,a&&a.copy(n),i&&i.copy(e))}return this.closestPointToPoint(c,n),u=c.distanceToSquared(n),u<f&&(f=u,a&&a.copy(n),i&&i.copy(c)),this.closestPointToPoint(r,n),u=r.distanceToSquared(n),u<f&&(f=u,a&&a.copy(n),i&&i.copy(r)),Math.sqrt(f)}})();tt.prototype.intersectsTriangle=(function(){const n=new tt,e=new Array(3),t=new Array(3),s=new rt,o=new rt,a=new L,i=new L,c=new L,r=new L,p=new L,u=new ot,f=new ot,l=new ot,d=new L;function A(b,m,h){const y=b.points;let w=0,g=-1;for(let x=0;x<3;x++){const{start:P,end:T}=u;P.copy(y[x]),T.copy(y[(x+1)%3]),u.delta(i);const C=Te(m.distanceToPoint(P));if(Te(m.normal.dot(i))&&C){h.copy(u),w=2;break}const B=m.intersectLine(u,d);if(!B&&C&&d.copy(P),(B||C)&&!Te(d.distanceTo(T))){if(w<=1)(w===1?h.start:h.end).copy(d),C&&(g=w);else if(w>=2){(g===1?h.start:h.end).copy(d),w=2;break}if(w++,w===2&&g===-1)break}}return w}return function(m,h=null,y=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(n.copy(m),n.update(),m=n);const w=this.plane,g=m.plane;if(Math.abs(w.normal.dot(g.normal))>1-1e-10){const x=this.satBounds,P=this.satAxes;t[0]=m.a,t[1]=m.b,t[2]=m.c;for(let B=0;B<4;B++){const _=x[B],S=P[B];if(s.setFromPoints(S,t),_.isSeparated(s))return!1}const T=m.satBounds,C=m.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let B=0;B<4;B++){const _=T[B],S=C[B];if(s.setFromPoints(S,e),_.isSeparated(s))return!1}for(let B=0;B<4;B++){const _=P[B];for(let S=0;S<4;S++){const M=C[S];if(a.crossVectors(_,M),s.setFromPoints(a,e),o.setFromPoints(a,t),s.isSeparated(o))return!1}}return h&&(y||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0)),!0}else{const x=A(this,g,f);if(x===1&&m.containsPoint(f.end))return h&&(h.start.copy(f.end),h.end.copy(f.end)),!0;if(x!==2)return!1;const P=A(m,w,l);if(P===1&&this.containsPoint(l.end))return h&&(h.start.copy(l.end),h.end.copy(l.end)),!0;if(P!==2)return!1;if(f.delta(c),l.delta(r),c.dot(r)<0){let E=l.start;l.start=l.end,l.end=E}const T=f.start.dot(c),C=f.end.dot(c),B=l.start.dot(c),_=l.end.dot(c),S=C<B,M=T<_;return T!==_&&B!==C&&S===M?!1:(h&&(p.subVectors(f.start,l.start),p.dot(c)>0?h.start.copy(f.start):h.start.copy(l.start),p.subVectors(f.end,l.end),p.dot(c)<0?h.end.copy(f.end):h.end.copy(l.end)),!0)}}})();tt.prototype.distanceToPoint=(function(){const n=new L;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}})();tt.prototype.distanceToTriangle=(function(){const n=new L,e=new L,t=["a","b","c"],s=new ot,o=new ot;return function(i,c=null,r=null){const p=c||r?s:null;if(this.intersectsTriangle(i,p))return(c||r)&&(c&&p.getCenter(c),r&&p.getCenter(r)),0;let u=1/0;for(let f=0;f<3;f++){let l;const d=t[f],A=i[d];this.closestPointToPoint(A,n),l=A.distanceToSquared(n),l<u&&(u=l,c&&c.copy(n),r&&r.copy(A));const b=this[d];i.closestPointToPoint(b,n),l=b.distanceToSquared(n),l<u&&(u=l,c&&c.copy(b),r&&r.copy(n))}for(let f=0;f<3;f++){const l=t[f],d=t[(f+1)%3];s.set(this[l],this[d]);for(let A=0;A<3;A++){const b=t[A],m=t[(A+1)%3];o.set(i[b],i[m]),ke(s,o,n,e);const h=n.distanceToSquared(e);h<u&&(u=h,c&&c.copy(n),r&&r.copy(e))}}return Math.sqrt(u)}})();class q{constructor(e,t,s){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new dt,this.invMatrix=new dt,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new rt),this.alignedSatBounds=new Array(3).fill().map(()=>new rt),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(e,t,s){this.min.copy(e),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}q.prototype.update=(function(){return function(){const e=this.matrix,t=this.min,s=this.max,o=this.points;for(let p=0;p<=1;p++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const l=1*p|2*u|4*f,d=o[l];d.x=p?s.x:t.x,d.y=u?s.y:t.y,d.z=f?s.z:t.z,d.applyMatrix4(e)}const a=this.satBounds,i=this.satAxes,c=o[0];for(let p=0;p<3;p++){const u=i[p],f=a[p],l=1<<p,d=o[l];u.subVectors(c,d),f.setFromPoints(u,o)}const r=this.alignedSatBounds;r[0].setFromPointsField(o,"x"),r[1].setFromPointsField(o,"y"),r[2].setFromPointsField(o,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();q.prototype.intersectsBox=(function(){const n=new rt;return function(t){this.needsUpdate&&this.update();const s=t.min,o=t.max,a=this.satBounds,i=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=o.x,c[0].isSeparated(n)||(n.min=s.y,n.max=o.y,c[1].isSeparated(n))||(n.min=s.z,n.max=o.z,c[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const p=i[r],u=a[r];if(n.setFromBox(p,t),u.isSeparated(n))return!1}return!0}})();q.prototype.intersectsTriangle=(function(){const n=new tt,e=new Array(3),t=new rt,s=new rt,o=new L;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(n.copy(i),n.update(),i=n);const c=this.satBounds,r=this.satAxes;e[0]=i.a,e[1]=i.b,e[2]=i.c;for(let l=0;l<3;l++){const d=c[l],A=r[l];if(t.setFromPoints(A,e),d.isSeparated(t))return!1}const p=i.satBounds,u=i.satAxes,f=this.points;for(let l=0;l<3;l++){const d=p[l],A=u[l];if(t.setFromPoints(A,f),d.isSeparated(t))return!1}for(let l=0;l<3;l++){const d=r[l];for(let A=0;A<4;A++){const b=u[A];if(o.crossVectors(d,b),t.setFromPoints(o,e),s.setFromPoints(o,f),t.isSeparated(s))return!1}}return!0}})();q.prototype.closestPointToPoint=(function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}})();q.prototype.distanceToPoint=(function(){const n=new L;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}})();q.prototype.distanceToBox=(function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new ot),t=new Array(12).fill().map(()=>new ot),s=new L,o=new L;return function(i,c=0,r=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(r||p)&&(i.getCenter(o),this.closestPointToPoint(o,s),i.closestPointToPoint(s,o),r&&r.copy(s),p&&p.copy(o)),0;const u=c*c,f=i.min,l=i.max,d=this.points;let A=1/0;for(let m=0;m<8;m++){const h=d[m];o.copy(h).clamp(f,l);const y=h.distanceToSquared(o);if(y<A&&(A=y,r&&r.copy(h),p&&p.copy(o),y<u))return Math.sqrt(y)}let b=0;for(let m=0;m<3;m++)for(let h=0;h<=1;h++)for(let y=0;y<=1;y++){const w=(m+1)%3,g=(m+2)%3,x=h<<w|y<<g,P=1<<m|h<<w|y<<g,T=d[x],C=d[P];e[b].set(T,C);const _=n[m],S=n[w],M=n[g],E=t[b],F=E.start,R=E.end;F[_]=f[_],F[S]=h?f[S]:l[S],F[M]=y?f[M]:l[S],R[_]=l[_],R[S]=h?f[S]:l[S],R[M]=y?f[M]:l[S],b++}for(let m=0;m<=1;m++)for(let h=0;h<=1;h++)for(let y=0;y<=1;y++){o.x=m?l.x:f.x,o.y=h?l.y:f.y,o.z=y?l.z:f.z,this.closestPointToPoint(o,s);const w=o.distanceToSquared(s);if(w<A&&(A=w,r&&r.copy(s),p&&p.copy(o),w<u))return Math.sqrt(w)}for(let m=0;m<12;m++){const h=e[m];for(let y=0;y<12;y++){const w=t[y];ke(h,w,s,o);const g=s.distanceToSquared(o);if(g<A&&(A=g,r&&r.copy(s),p&&p.copy(o),g<u))return Math.sqrt(g)}}return Math.sqrt(A)}})();class qe{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class ws extends qe{constructor(){super(()=>new tt)}}const O=new ws;class xs{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=s=>{t&&e.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const D=new xs;let pt,Lt;const bt=[],Ot=new qe(()=>new et);function gs(n,e,t,s,o,a){pt=Ot.getPrimitive(),Lt=Ot.getPrimitive(),bt.push(pt,Lt),D.setBuffer(n._roots[e]);const i=Le(0,n.geometry,t,s,o,a);D.clearBuffer(),Ot.releasePrimitive(pt),Ot.releasePrimitive(Lt),bt.pop(),bt.pop();const c=bt.length;return c>0&&(Lt=bt[c-1],pt=bt[c-2]),i}function Le(n,e,t,s,o=null,a=0,i=0){const{float32Array:c,uint16Array:r,uint32Array:p}=D;let u=n*2;if($(u,r)){const l=Z(n,p),d=Y(u,r);return U(n,c,pt),s(l,d,!1,i,a+n,pt)}else{let _=function(M){const{uint16Array:E,uint32Array:F}=D;let R=M*2;for(;!$(R,E);)M=G(M),R=M*2;return Z(M,F)},S=function(M){const{uint16Array:E,uint32Array:F}=D;let R=M*2;for(;!$(R,E);)M=J(M,F),R=M*2;return Z(M,F)+Y(R,E)};const l=G(n),d=J(n,p);let A=l,b=d,m,h,y,w;if(o&&(y=pt,w=Lt,U(A,c,y),U(b,c,w),m=o(y),h=o(w),h<m)){A=d,b=l;const M=m;m=h,h=M,y=w}y||(y=pt,U(A,c,y));const g=$(A*2,r),x=t(y,g,m,i+1,a+A);let P;if(x===je){const M=_(A),F=S(A)-M;P=s(M,F,!0,i+1,a+A,y)}else P=x&&Le(A,e,t,s,o,a,i+1);if(P)return!0;w=Lt,U(b,c,w);const T=$(b*2,r),C=t(w,T,h,i+1,a+b);let B;if(C===je){const M=_(b),F=S(b)-M;B=s(M,F,!0,i+1,a+b,w)}else B=C&&Le(b,e,t,s,o,a,i+1);return!!B}}const Ut=new L,be=new L;function As(n,e,t={},s=0,o=1/0){const a=s*s,i=o*o;let c=1/0,r=null;if(n.shapecast({boundsTraverseOrder:u=>(Ut.copy(e).clamp(u.min,u.max),Ut.distanceToSquared(e)),intersectsBounds:(u,f,l)=>l<c&&l<i,intersectsTriangle:(u,f)=>{u.closestPointToPoint(e,Ut);const l=e.distanceToSquared(Ut);return l<c&&(be.copy(Ut),c=l,r=f),l<a}}),c===1/0)return null;const p=Math.sqrt(c);return t.point?t.point.copy(be):t.point=be.clone(),t.distance=p,t.faceIndex=r,t}const Ts=parseInt(Sn)>=169,mt=new L,wt=new L,xt=new L,Kt=new Tt,Qt=new Tt,te=new Tt,Oe=new L,Ke=new L,Qe=new L,It=new L;function bs(n,e,t,s,o,a,i,c){let r;if(a===Pn?r=n.intersectTriangle(s,t,e,!0,o):r=n.intersectTriangle(e,t,s,a!==Bn,o),r===null)return null;const p=n.origin.distanceTo(o);return p<i||p>c?null:{distance:p,point:o.clone()}}function Ps(n,e,t,s,o,a,i,c,r,p,u){mt.fromBufferAttribute(e,a),wt.fromBufferAttribute(e,i),xt.fromBufferAttribute(e,c);const f=bs(n,mt,wt,xt,It,r,p,u);if(f){const l=new L;Et.getBarycoord(It,mt,wt,xt,l),s&&(Kt.fromBufferAttribute(s,a),Qt.fromBufferAttribute(s,i),te.fromBufferAttribute(s,c),f.uv=Et.getInterpolation(It,mt,wt,xt,Kt,Qt,te,new Tt)),o&&(Kt.fromBufferAttribute(o,a),Qt.fromBufferAttribute(o,i),te.fromBufferAttribute(o,c),f.uv1=Et.getInterpolation(It,mt,wt,xt,Kt,Qt,te,new Tt)),t&&(Oe.fromBufferAttribute(t,a),Ke.fromBufferAttribute(t,i),Qe.fromBufferAttribute(t,c),f.normal=Et.getInterpolation(It,mt,wt,xt,Oe,Ke,Qe,new L),f.normal.dot(n.direction)>0&&f.normal.multiplyScalar(-1));const d={a,b:i,c,normal:new L,materialIndex:0};Et.getNormal(mt,wt,xt,d.normal),f.face=d,f.faceIndex=a,Ts&&(f.barycoord=l)}return f}function he(n,e,t,s,o,a,i){const c=s*3;let r=c+0,p=c+1,u=c+2;const f=n.index;n.index&&(r=f.getX(r),p=f.getX(p),u=f.getX(u));const{position:l,normal:d,uv:A,uv1:b}=n.attributes,m=Ps(t,l,d,A,b,r,p,u,e,a,i);return m?(m.faceIndex=s,o&&o.push(m),m):null}function V(n,e,t,s){const o=n.a,a=n.b,i=n.c;let c=e,r=e+1,p=e+2;t&&(c=t.getX(c),r=t.getX(r),p=t.getX(p)),o.x=s.getX(c),o.y=s.getY(c),o.z=s.getZ(c),a.x=s.getX(r),a.y=s.getY(r),a.z=s.getZ(r),i.x=s.getX(p),i.y=s.getY(p),i.z=s.getZ(p)}function Bs(n,e,t,s,o,a,i,c){const{geometry:r,_indirectBuffer:p}=n;for(let u=s,f=s+o;u<f;u++)he(r,e,t,u,a,i,c)}function Ss(n,e,t,s,o,a,i){const{geometry:c,_indirectBuffer:r}=n;let p=1/0,u=null;for(let f=s,l=s+o;f<l;f++){let d;d=he(c,e,t,f,null,a,i),d&&d.distance<p&&(u=d,p=d.distance)}return u}function Ms(n,e,t,s,o,a,i){const{geometry:c}=t,{index:r}=c,p=c.attributes.position;for(let u=n,f=e+n;u<f;u++){let l;if(l=u,V(i,l*3,r,p),i.needsUpdate=!0,s(i,l,o,a))return!0}return!1}function Cs(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,o=t.attributes.position;let a,i,c,r,p=0;const u=n._roots;for(let l=0,d=u.length;l<d;l++)a=u[l],i=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,d,A=!1){const b=l*2;if(c[b+15]===ye){const h=i[l+6],y=c[b+14];let w=1/0,g=1/0,x=1/0,P=-1/0,T=-1/0,C=-1/0;for(let B=3*h,_=3*(h+y);B<_;B++){let S=s[B];const M=o.getX(S),E=o.getY(S),F=o.getZ(S);M<w&&(w=M),M>P&&(P=M),E<g&&(g=E),E>T&&(T=E),F<x&&(x=F),F>C&&(C=F)}return r[l+0]!==w||r[l+1]!==g||r[l+2]!==x||r[l+3]!==P||r[l+4]!==T||r[l+5]!==C?(r[l+0]=w,r[l+1]=g,r[l+2]=x,r[l+3]=P,r[l+4]=T,r[l+5]=C,!0):!1}else{const h=l+8,y=i[l+6],w=h+d,g=y+d;let x=A,P=!1,T=!1;e?x||(P=e.has(w),T=e.has(g),x=!P&&!T):(P=!0,T=!0);const C=x||P,B=x||T;let _=!1;C&&(_=f(h,d,x));let S=!1;B&&(S=f(y,d,x));const M=_||S;if(M)for(let E=0;E<3;E++){const F=h+E,R=y+E,I=r[F],ct=r[F+3],Rt=r[R],Dt=r[R+3];r[l+E]=I<Rt?I:Rt,r[l+E+3]=ct>Dt?ct:Dt}return M}}}function yt(n,e,t,s,o){let a,i,c,r,p,u;const f=1/t.direction.x,l=1/t.direction.y,d=1/t.direction.z,A=t.origin.x,b=t.origin.y,m=t.origin.z;let h=e[n],y=e[n+3],w=e[n+1],g=e[n+3+1],x=e[n+2],P=e[n+3+2];return f>=0?(a=(h-A)*f,i=(y-A)*f):(a=(y-A)*f,i=(h-A)*f),l>=0?(c=(w-b)*l,r=(g-b)*l):(c=(g-b)*l,r=(w-b)*l),a>r||c>i||((c>a||isNaN(a))&&(a=c),(r<i||isNaN(i))&&(i=r),d>=0?(p=(x-m)*d,u=(P-m)*d):(p=(P-m)*d,u=(x-m)*d),a>u||p>i)?!1:((p>a||a!==a)&&(a=p),(u<i||i!==i)&&(i=u),a<=o&&i>=s)}function _s(n,e,t,s,o,a,i,c){const{geometry:r,_indirectBuffer:p}=n;for(let u=s,f=s+o;u<f;u++){let l=p?p[u]:u;he(r,e,t,l,a,i,c)}}function Es(n,e,t,s,o,a,i){const{geometry:c,_indirectBuffer:r}=n;let p=1/0,u=null;for(let f=s,l=s+o;f<l;f++){let d;d=he(c,e,t,r?r[f]:f,null,a,i),d&&d.distance<p&&(u=d,p=d.distance)}return u}function Ls(n,e,t,s,o,a,i){const{geometry:c}=t,{index:r}=c,p=c.attributes.position;for(let u=n,f=e+n;u<f;u++){let l;if(l=t.resolveTriangleIndex(u),V(i,l*3,r,p),i.needsUpdate=!0,s(i,l,o,a))return!0}return!1}function Fs(n,e,t,s,o,a,i){D.setBuffer(n._roots[e]),Fe(0,n,t,s,o,a,i),D.clearBuffer()}function Fe(n,e,t,s,o,a,i){const{float32Array:c,uint16Array:r,uint32Array:p}=D,u=n*2;if($(u,r)){const l=Z(n,p),d=Y(u,r);Bs(e,t,s,l,d,o,a,i)}else{const l=G(n);yt(l,c,s,a,i)&&Fe(l,e,t,s,o,a,i);const d=J(n,p);yt(d,c,s,a,i)&&Fe(d,e,t,s,o,a,i)}}const Rs=["x","y","z"];function Ds(n,e,t,s,o,a){D.setBuffer(n._roots[e]);const i=Re(0,n,t,s,o,a);return D.clearBuffer(),i}function Re(n,e,t,s,o,a){const{float32Array:i,uint16Array:c,uint32Array:r}=D;let p=n*2;if($(p,c)){const f=Z(n,r),l=Y(p,c);return Ss(e,t,s,f,l,o,a)}else{const f=xn(n,r),l=Rs[f],A=s.direction[l]>=0;let b,m;A?(b=G(n),m=J(n,r)):(b=J(n,r),m=G(n));const y=yt(b,i,s,o,a)?Re(b,e,t,s,o,a):null;if(y){const x=y.point[l];if(A?x<=i[m+f]:x>=i[m+f+3])return y}const g=yt(m,i,s,o,a)?Re(m,e,t,s,o,a):null;return y&&g?y.distance<=g.distance?y:g:y||g||null}}const ee=new et,Pt=new tt,Bt=new tt,Nt=new dt,tn=new q,ne=new q;function vs(n,e,t,s){D.setBuffer(n._roots[e]);const o=De(0,n,t,s);return D.clearBuffer(),o}function De(n,e,t,s,o=null){const{float32Array:a,uint16Array:i,uint32Array:c}=D;let r=n*2;if(o===null&&(t.boundingBox||t.computeBoundingBox(),tn.set(t.boundingBox.min,t.boundingBox.max,s),o=tn),$(r,i)){const u=e.geometry,f=u.index,l=u.attributes.position,d=t.index,A=t.attributes.position,b=Z(n,c),m=Y(r,i);if(Nt.copy(s).invert(),t.boundsTree)return U(n,a,ne),ne.matrix.copy(Nt),ne.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:y=>ne.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let w=b*3,g=(m+b)*3;w<g;w+=3)if(V(Bt,w,f,l),Bt.needsUpdate=!0,y.intersectsTriangle(Bt))return!0;return!1}});for(let h=b*3,y=(m+b)*3;h<y;h+=3){V(Pt,h,f,l),Pt.a.applyMatrix4(Nt),Pt.b.applyMatrix4(Nt),Pt.c.applyMatrix4(Nt),Pt.needsUpdate=!0;for(let w=0,g=d.count;w<g;w+=3)if(V(Bt,w,d,A),Bt.needsUpdate=!0,Pt.intersectsTriangle(Bt))return!0}}else{const u=n+8,f=c[n+6];return U(u,a,ee),!!(o.intersectsBox(ee)&&De(u,e,t,s,o)||(U(f,a,ee),o.intersectsBox(ee)&&De(f,e,t,s,o)))}}const se=new dt,Pe=new q,Vt=new q,Us=new L,Is=new L,Ns=new L,Vs=new L;function zs(n,e,t,s={},o={},a=0,i=1/0){e.boundingBox||e.computeBoundingBox(),Pe.set(e.boundingBox.min,e.boundingBox.max,t),Pe.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,p=c.index,u=e.attributes.position,f=e.index,l=O.getPrimitive(),d=O.getPrimitive();let A=Us,b=Is,m=null,h=null;o&&(m=Ns,h=Vs);let y=1/0,w=null,g=null;return se.copy(t).invert(),Vt.matrix.copy(se),n.shapecast({boundsTraverseOrder:x=>Pe.distanceToBox(x),intersectsBounds:(x,P,T)=>T<y&&T<i?(P&&(Vt.min.copy(x.min),Vt.max.copy(x.max),Vt.needsUpdate=!0),!0):!1,intersectsRange:(x,P)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:C=>Vt.distanceToBox(C),intersectsBounds:(C,B,_)=>_<y&&_<i,intersectsRange:(C,B)=>{for(let _=C,S=C+B;_<S;_++){V(d,3*_,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let M=x,E=x+P;M<E;M++){V(l,3*M,p,r),l.needsUpdate=!0;const F=l.distanceToTriangle(d,A,m);if(F<y&&(b.copy(A),h&&h.copy(m),y=F,w=M,g=_),F<a)return!0}}}});{const T=Ft(e);for(let C=0,B=T;C<B;C++){V(d,3*C,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let _=x,S=x+P;_<S;_++){V(l,3*_,p,r),l.needsUpdate=!0;const M=l.distanceToTriangle(d,A,m);if(M<y&&(b.copy(A),h&&h.copy(m),y=M,w=_,g=C),M<a)return!0}}}}}),O.releasePrimitive(l),O.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(b):s.point=b.clone(),s.distance=y,s.faceIndex=w,o&&(o.point?o.point.copy(h):o.point=h.clone(),o.point.applyMatrix4(se),b.applyMatrix4(se),o.distance=b.sub(o.point).length(),o.faceIndex=g),s)}function ks(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,o=t.attributes.position;let a,i,c,r,p=0;const u=n._roots;for(let l=0,d=u.length;l<d;l++)a=u[l],i=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,d,A=!1){const b=l*2;if(c[b+15]===ye){const h=i[l+6],y=c[b+14];let w=1/0,g=1/0,x=1/0,P=-1/0,T=-1/0,C=-1/0;for(let B=h,_=h+y;B<_;B++){const S=3*n.resolveTriangleIndex(B);for(let M=0;M<3;M++){let E=S+M;E=s?s[E]:E;const F=o.getX(E),R=o.getY(E),I=o.getZ(E);F<w&&(w=F),F>P&&(P=F),R<g&&(g=R),R>T&&(T=R),I<x&&(x=I),I>C&&(C=I)}}return r[l+0]!==w||r[l+1]!==g||r[l+2]!==x||r[l+3]!==P||r[l+4]!==T||r[l+5]!==C?(r[l+0]=w,r[l+1]=g,r[l+2]=x,r[l+3]=P,r[l+4]=T,r[l+5]=C,!0):!1}else{const h=l+8,y=i[l+6],w=h+d,g=y+d;let x=A,P=!1,T=!1;e?x||(P=e.has(w),T=e.has(g),x=!P&&!T):(P=!0,T=!0);const C=x||P,B=x||T;let _=!1;C&&(_=f(h,d,x));let S=!1;B&&(S=f(y,d,x));const M=_||S;if(M)for(let E=0;E<3;E++){const F=h+E,R=y+E,I=r[F],ct=r[F+3],Rt=r[R],Dt=r[R+3];r[l+E]=I<Rt?I:Rt,r[l+E+3]=ct>Dt?ct:Dt}return M}}}function qs(n,e,t,s,o,a,i){D.setBuffer(n._roots[e]),ve(0,n,t,s,o,a,i),D.clearBuffer()}function ve(n,e,t,s,o,a,i){const{float32Array:c,uint16Array:r,uint32Array:p}=D,u=n*2;if($(u,r)){const l=Z(n,p),d=Y(u,r);_s(e,t,s,l,d,o,a,i)}else{const l=G(n);yt(l,c,s,a,i)&&ve(l,e,t,s,o,a,i);const d=J(n,p);yt(d,c,s,a,i)&&ve(d,e,t,s,o,a,i)}}const Hs=["x","y","z"];function $s(n,e,t,s,o,a){D.setBuffer(n._roots[e]);const i=Ue(0,n,t,s,o,a);return D.clearBuffer(),i}function Ue(n,e,t,s,o,a){const{float32Array:i,uint16Array:c,uint32Array:r}=D;let p=n*2;if($(p,c)){const f=Z(n,r),l=Y(p,c);return Es(e,t,s,f,l,o,a)}else{const f=xn(n,r),l=Hs[f],A=s.direction[l]>=0;let b,m;A?(b=G(n),m=J(n,r)):(b=J(n,r),m=G(n));const y=yt(b,i,s,o,a)?Ue(b,e,t,s,o,a):null;if(y){const x=y.point[l];if(A?x<=i[m+f]:x>=i[m+f+3])return y}const g=yt(m,i,s,o,a)?Ue(m,e,t,s,o,a):null;return y&&g?y.distance<=g.distance?y:g:y||g||null}}const ie=new et,St=new tt,Mt=new tt,zt=new dt,en=new q,oe=new q;function Ws(n,e,t,s){D.setBuffer(n._roots[e]);const o=Ie(0,n,t,s);return D.clearBuffer(),o}function Ie(n,e,t,s,o=null){const{float32Array:a,uint16Array:i,uint32Array:c}=D;let r=n*2;if(o===null&&(t.boundingBox||t.computeBoundingBox(),en.set(t.boundingBox.min,t.boundingBox.max,s),o=en),$(r,i)){const u=e.geometry,f=u.index,l=u.attributes.position,d=t.index,A=t.attributes.position,b=Z(n,c),m=Y(r,i);if(zt.copy(s).invert(),t.boundsTree)return U(n,a,oe),oe.matrix.copy(zt),oe.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:y=>oe.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let w=b,g=m+b;w<g;w++)if(V(Mt,3*e.resolveTriangleIndex(w),f,l),Mt.needsUpdate=!0,y.intersectsTriangle(Mt))return!0;return!1}});for(let h=b,y=m+b;h<y;h++){const w=e.resolveTriangleIndex(h);V(St,3*w,f,l),St.a.applyMatrix4(zt),St.b.applyMatrix4(zt),St.c.applyMatrix4(zt),St.needsUpdate=!0;for(let g=0,x=d.count;g<x;g+=3)if(V(Mt,g,d,A),Mt.needsUpdate=!0,St.intersectsTriangle(Mt))return!0}}else{const u=n+8,f=c[n+6];return U(u,a,ie),!!(o.intersectsBox(ie)&&Ie(u,e,t,s,o)||(U(f,a,ie),o.intersectsBox(ie)&&Ie(f,e,t,s,o)))}}const re=new dt,Be=new q,kt=new q,Xs=new L,js=new L,Zs=new L,Ys=new L;function Gs(n,e,t,s={},o={},a=0,i=1/0){e.boundingBox||e.computeBoundingBox(),Be.set(e.boundingBox.min,e.boundingBox.max,t),Be.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,p=c.index,u=e.attributes.position,f=e.index,l=O.getPrimitive(),d=O.getPrimitive();let A=Xs,b=js,m=null,h=null;o&&(m=Zs,h=Ys);let y=1/0,w=null,g=null;return re.copy(t).invert(),kt.matrix.copy(re),n.shapecast({boundsTraverseOrder:x=>Be.distanceToBox(x),intersectsBounds:(x,P,T)=>T<y&&T<i?(P&&(kt.min.copy(x.min),kt.max.copy(x.max),kt.needsUpdate=!0),!0):!1,intersectsRange:(x,P)=>{if(e.boundsTree){const T=e.boundsTree;return T.shapecast({boundsTraverseOrder:C=>kt.distanceToBox(C),intersectsBounds:(C,B,_)=>_<y&&_<i,intersectsRange:(C,B)=>{for(let _=C,S=C+B;_<S;_++){const M=T.resolveTriangleIndex(_);V(d,3*M,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let E=x,F=x+P;E<F;E++){const R=n.resolveTriangleIndex(E);V(l,3*R,p,r),l.needsUpdate=!0;const I=l.distanceToTriangle(d,A,m);if(I<y&&(b.copy(A),h&&h.copy(m),y=I,w=E,g=_),I<a)return!0}}}})}else{const T=Ft(e);for(let C=0,B=T;C<B;C++){V(d,3*C,f,u),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let _=x,S=x+P;_<S;_++){const M=n.resolveTriangleIndex(_);V(l,3*M,p,r),l.needsUpdate=!0;const E=l.distanceToTriangle(d,A,m);if(E<y&&(b.copy(A),h&&h.copy(m),y=E,w=_,g=C),E<a)return!0}}}}}),O.releasePrimitive(l),O.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(b):s.point=b.clone(),s.distance=y,s.faceIndex=w,o&&(o.point?o.point.copy(h):o.point=h.clone(),o.point.applyMatrix4(re),b.applyMatrix4(re),o.distance=b.sub(o.point).length(),o.faceIndex=g),s)}function Js(){return typeof SharedArrayBuffer<"u"}const jt=new D.constructor,de=new D.constructor,ft=new qe(()=>new et),Ct=new et,_t=new et,Se=new et,Me=new et;let Ce=!1;function Os(n,e,t,s){if(Ce)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ce=!0;const o=n._roots,a=e._roots;let i,c=0,r=0;const p=new dt().copy(t).invert();for(let u=0,f=o.length;u<f;u++){jt.setBuffer(o[u]),r=0;const l=ft.getPrimitive();U(0,jt.float32Array,l),l.applyMatrix4(p);for(let d=0,A=a.length;d<A&&(de.setBuffer(a[d]),i=K(0,0,t,p,s,c,r,0,0,l),de.clearBuffer(),r+=a[d].length,!i);d++);if(ft.releasePrimitive(l),jt.clearBuffer(),c+=o[u].length,i)break}return Ce=!1,i}function K(n,e,t,s,o,a=0,i=0,c=0,r=0,p=null,u=!1){let f,l;u?(f=de,l=jt):(f=jt,l=de);const d=f.float32Array,A=f.uint32Array,b=f.uint16Array,m=l.float32Array,h=l.uint32Array,y=l.uint16Array,w=n*2,g=e*2,x=$(w,b),P=$(g,y);let T=!1;if(P&&x)u?T=o(Z(e,h),Y(e*2,y),Z(n,A),Y(n*2,b),r,i+e,c,a+n):T=o(Z(n,A),Y(n*2,b),Z(e,h),Y(e*2,y),c,a+n,r,i+e);else if(P){const C=ft.getPrimitive();U(e,m,C),C.applyMatrix4(t);const B=G(n),_=J(n,A);U(B,d,Ct),U(_,d,_t);const S=C.intersectsBox(Ct),M=C.intersectsBox(_t);T=S&&K(e,B,s,t,o,i,a,r,c+1,C,!u)||M&&K(e,_,s,t,o,i,a,r,c+1,C,!u),ft.releasePrimitive(C)}else{const C=G(e),B=J(e,h);U(C,m,Se),U(B,m,Me);const _=p.intersectsBox(Se),S=p.intersectsBox(Me);if(_&&S)T=K(n,C,t,s,o,a,i,c,r+1,p,u)||K(n,B,t,s,o,a,i,c,r+1,p,u);else if(_)if(x)T=K(n,C,t,s,o,a,i,c,r+1,p,u);else{const M=ft.getPrimitive();M.copy(Se).applyMatrix4(t);const E=G(n),F=J(n,A);U(E,d,Ct),U(F,d,_t);const R=M.intersectsBox(Ct),I=M.intersectsBox(_t);T=R&&K(C,E,s,t,o,i,a,r,c+1,M,!u)||I&&K(C,F,s,t,o,i,a,r,c+1,M,!u),ft.releasePrimitive(M)}else if(S)if(x)T=K(n,B,t,s,o,a,i,c,r+1,p,u);else{const M=ft.getPrimitive();M.copy(Me).applyMatrix4(t);const E=G(n),F=J(n,A);U(E,d,Ct),U(F,d,_t);const R=M.intersectsBox(Ct),I=M.intersectsBox(_t);T=R&&K(B,E,s,t,o,i,a,r,c+1,M,!u)||I&&K(B,F,s,t,o,i,a,r,c+1,M,!u),ft.releasePrimitive(M)}}return T}const ce=new q,nn=new et,Ks={strategy:hn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class He{static serialize(e,t={}){t={cloneBuffers:!0,...t};const s=e.geometry,o=e._roots,a=e._indirectBuffer,i=s.getIndex();let c;return t.cloneBuffers?c={roots:o.map(r=>r.slice()),index:i?i.array.slice():null,indirectBuffer:a?a.slice():null}:c={roots:o,index:i?i.array:null,indirectBuffer:a},c}static deserialize(e,t,s={}){s={setIndex:!0,indirect:!!e.indirectBuffer,...s};const{index:o,roots:a,indirectBuffer:i}=e,c=new He(t,{...s,[xe]:!0});if(c._roots=a,c._indirectBuffer=i||null,s.setIndex){const r=t.getIndex();if(r===null){const p=new un(e.index,1,!1);t.setIndex(p)}else r.array!==o&&(r.array.set(o),r.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...Ks,[xe]:!1},t),t.useSharedArrayBuffer&&!Js())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[xe]||(ds(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new et))),this.resolveTriangleIndex=t.indirect?s=>this._indirectBuffer[s]:s=>s}refit(e=null){return(this.indirect?ks:Cs)(this,e)}traverse(e,t=0){const s=this._roots[t],o=new Uint32Array(s),a=new Uint16Array(s);i(0);function i(c,r=0){const p=c*2,u=a[p+15]===ye;if(u){const f=o[c+6],l=a[p+14];e(r,u,new Float32Array(s,c*4,6),f,l)}else{const f=c+Xt/4,l=o[c+6],d=o[c+7];e(r,u,new Float32Array(s,c*4,6),d)||(i(f,r+1),i(l,r+1))}}}raycast(e,t=$e,s=0,o=1/0){const a=this._roots,i=this.geometry,c=[],r=t.isMaterial,p=Array.isArray(t),u=i.groups,f=r?t.side:t,l=this.indirect?qs:Fs;for(let d=0,A=a.length;d<A;d++){const b=p?t[u[d].materialIndex].side:f,m=c.length;if(l(this,d,b,e,c,s,o),p){const h=u[d].materialIndex;for(let y=m,w=c.length;y<w;y++)c[y].face.materialIndex=h}}return c}raycastFirst(e,t=$e,s=0,o=1/0){const a=this._roots,i=this.geometry,c=t.isMaterial,r=Array.isArray(t);let p=null;const u=i.groups,f=c?t.side:t,l=this.indirect?$s:Ds;for(let d=0,A=a.length;d<A;d++){const b=r?t[u[d].materialIndex].side:f,m=l(this,d,b,e,s,o);m!=null&&(p==null||m.distance<p.distance)&&(p=m,r&&(m.face.materialIndex=u[d].materialIndex))}return p}intersectsGeometry(e,t){let s=!1;const o=this._roots,a=this.indirect?Ws:vs;for(let i=0,c=o.length;i<c&&(s=a(this,i,e,t),!s);i++);return s}shapecast(e){const t=O.getPrimitive(),s=this.indirect?Ls:Ms;let{boundsTraverseOrder:o,intersectsBounds:a,intersectsRange:i,intersectsTriangle:c}=e;if(i&&c){const f=i;i=(l,d,A,b,m)=>f(l,d,A,b,m)?!0:s(l,d,this,c,A,b,t)}else i||(c?i=(f,l,d,A)=>s(f,l,this,c,d,A,t):i=(f,l,d)=>d);let r=!1,p=0;const u=this._roots;for(let f=0,l=u.length;f<l;f++){const d=u[f];if(r=gs(this,f,a,i,o,p),r)break;p+=d.byteLength}return O.releasePrimitive(t),r}bvhcast(e,t,s){let{intersectsRanges:o,intersectsTriangles:a}=s;const i=O.getPrimitive(),c=this.geometry.index,r=this.geometry.attributes.position,p=this.indirect?A=>{const b=this.resolveTriangleIndex(A);V(i,b*3,c,r)}:A=>{V(i,A*3,c,r)},u=O.getPrimitive(),f=e.geometry.index,l=e.geometry.attributes.position,d=e.indirect?A=>{const b=e.resolveTriangleIndex(A);V(u,b*3,f,l)}:A=>{V(u,A*3,f,l)};if(a){const A=(b,m,h,y,w,g,x,P)=>{for(let T=h,C=h+y;T<C;T++){d(T),u.a.applyMatrix4(t),u.b.applyMatrix4(t),u.c.applyMatrix4(t),u.needsUpdate=!0;for(let B=b,_=b+m;B<_;B++)if(p(B),i.needsUpdate=!0,a(i,u,B,T,w,g,x,P))return!0}return!1};if(o){const b=o;o=function(m,h,y,w,g,x,P,T){return b(m,h,y,w,g,x,P,T)?!0:A(m,h,y,w,g,x,P,T)}}else o=A}return Os(this,e,t,o)}intersectsBox(e,t){return ce.set(e.min,e.max,t),ce.needsUpdate=!0,this.shapecast({intersectsBounds:s=>ce.intersectsBox(s),intersectsTriangle:s=>ce.intersectsTriangle(s)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,s={},o={},a=0,i=1/0){return(this.indirect?Gs:zs)(this,e,t,s,o,a,i)}closestPointToPoint(e,t={},s=0,o=1/0){return As(this,e,t,s,o)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(s=>{U(0,new Float32Array(s),nn),e.union(nn)}),e}}function sn(n,e,t){return n===null?null:(n.point.applyMatrix4(e.matrixWorld),n.distance=n.point.distanceTo(t.ray.origin),n.object=e,n)}const ae=new Cn,on=new L,rn=new dt,Qs=Yt.prototype.raycast,ti=Mn.prototype.raycast,cn=new L,z=new Yt,le=[];function ei(n,e){this.isBatchedMesh?ni.call(this,n,e):si.call(this,n,e)}function ni(n,e){if(this.boundsTrees){const t=this.boundsTrees,s=this._drawInfo||this._instanceInfo,o=this._drawRanges||this._geometryInfo,a=this.matrixWorld;z.material=this.material,z.geometry=this.geometry;const i=z.geometry.boundsTree,c=z.geometry.drawRange;z.geometry.boundingSphere===null&&(z.geometry.boundingSphere=new pn);for(let r=0,p=s.length;r<p;r++){if(!this.getVisibleAt(r))continue;const u=s[r].geometryIndex;if(z.geometry.boundsTree=t[u],this.getMatrixAt(r,z.matrixWorld).premultiply(a),!z.geometry.boundsTree){this.getBoundingBoxAt(u,z.geometry.boundingBox),this.getBoundingSphereAt(u,z.geometry.boundingSphere);const f=o[u];z.geometry.setDrawRange(f.start,f.count)}z.raycast(n,le);for(let f=0,l=le.length;f<l;f++){const d=le[f];d.object=this,d.batchId=r,e.push(d)}le.length=0}z.geometry.boundsTree=i,z.geometry.drawRange=c,z.material=null,z.geometry=null}else ti.call(this,n,e)}function si(n,e){if(this.geometry.boundsTree){if(this.material===void 0)return;rn.copy(this.matrixWorld).invert(),ae.copy(n.ray).applyMatrix4(rn),cn.setFromMatrixScale(this.matrixWorld),on.copy(ae.direction).multiply(cn);const t=on.length(),s=n.near/t,o=n.far/t,a=this.geometry.boundsTree;if(n.firstHitOnly===!0){const i=sn(a.raycastFirst(ae,this.material,s,o),this,n);i&&e.push(i)}else{const i=a.raycast(ae,this.material,s,o);for(let c=0,r=i.length;c<r;c++){const p=sn(i[c],this,n);p&&e.push(p)}}}else Qs.call(this,n,e)}function ii(n={}){return this.boundsTree=new He(this,n),this.boundsTree}function oi(){this.boundsTree=null}Yt.prototype.raycast=ei;dn.prototype.computeBoundsTree=ii;dn.prototype.disposeBoundsTree=oi;const k={solve:!0,displayMesh:!0,displayIk:!1,enableControls:!0,terrainHeight:.35,settleIterations:10},ri={maxIterations:10,divergeThreshold:.05,stallThreshold:1e-4,translationErrorClamp:1,rotationErrorClamp:.25};let gt,Ne,Tn,Q,st,At,Ve,qt,H,N,it,X,Zt=!0;const an=new Tt,ln=new L,ue=new _n,Ht=new Float64Array(3);let j,v,pe,Wt,ze;ci();bn();function ci(){Ne=new Hn,document.body.appendChild(Ne.dom),Tn=document.getElementById("output"),Q=new En({antialias:!0}),Q.setPixelRatio(window.devicePixelRatio),Q.setSize(window.innerWidth,window.innerHeight),Q.shadowMap.enabled=!0,Q.shadowMap.type=Ln,document.body.appendChild(Q.domElement),At=new Fn(50,window.innerWidth/window.innerHeight),At.position.set(8,8,8),st=new Rn,st.background=new Dn(1971741),X=new vn,X.position.set(1,3,2),X.intensity=3*.75,X.castShadow=!0,X.shadow.normalBias=1e-4,X.shadow.mapSize.setScalar(1024);const n=X.shadow.camera;n.top=n.right=2,n.left=n.bottom=-2,n.updateProjectionMatrix(),st.add(X,X.target);const e=new Un(2038302,3);st.add(e),qt=new $n(At,Q.domElement),H=new Wn(At,Q.domElement),H.setSpace("local"),st.add(H.getHelper()),H.addEventListener("mouseDown",()=>qt.enabled=!1),H.addEventListener("mouseUp",()=>qt.enabled=!0),N=new In,N.position.set(0,0,0),N.rotation.set(Math.PI/2,0,0),st.add(N),H.attach(N),H.addEventListener("objectChange",()=>{Zt=!0});const t=400;it=new Yt(new Nn(25,25,t,t),new Vn);const s=it.geometry.attributes.position;for(let a=0;a<=t+1;a++)for(let i=0;i<=t+1;i++){const c=t*a+i,r=s.getX(c)*1.5,p=s.getY(c)*1.5;s.setZ(c,Math.min(Math.abs(Math.sin(p)),Math.abs(Math.sin(r))))}it.rotation.set(-Math.PI/2,0,0),it.geometry.computeVertexNormals(),it.receiveShadow=!0,it.geometry.computeBoundsTree(),st.add(it),gt=new zn,gt.add(k,"enableControls"),gt.add(k,"solve"),gt.add(k,"displayMesh"),gt.add(k,"displayIk"),gt.add(k,"settleIterations").min(1).max(20).step(1).onChange(()=>Zt=!0),gt.add(k,"terrainHeight",.05,.7).onChange(()=>Zt=!0);const o=new Xn;o.fetchOptions={mode:"cors"},o.loadMeshCb=(a,i,c)=>{/\.glb$/.test(a)||/\.gltf$/.test(a)?new Gn(i).load(a,r=>{r.scene.traverse(p=>{p.castShadow=!0,p.receiveShadow=!0,p.geometry&&!p.geometry.attributes.normals&&p.geometry.computeVertexNormals()}),c(r.scene)}):/\.stl$/.test(a)&&new jn(i).load(a,r=>{const p=new Yt(r);p.castShadow=!0,p.receiveShadow=!0,c(p)})},o.loadAsync("https://raw.githubusercontent.com/gkjohnson/m2020-urdf-models/main/rover/m2020.urdf").then(a=>{a.traverse(S=>{S.jointType==="floating"&&(S.jointType="fixed")}),j=a,v=Zn(j,!0);const i=v.find(S=>S.name==="CENTER_DIFFERENTIAL").child;i.removeChild(i.children[0]);const c=v.find(S=>S.name==="LEFT_DIFFERENTIAL").child,r=new at;i.addChild(r);const p=new lt;p.setPosition(0,-.7,0),r.addChild(p);const u=new at;u.setDoF(W.EZ),p.addChild(u);const f=new lt;f.setPosition(0,0,0),u.addChild(f);const l=new at;l.setDoF(W.EY),f.addChild(l);const d=new lt;c.getWorldPosition(d.position),d.setMatrixNeedsUpdate(),l.attachChild(d),d.position[1]=0,d.position[2]=0,d.setMatrixNeedsUpdate();const A=new at;c.addChild(A);const b=new lt;d.getWorldPosition(b.position),d.getWorldQuaternion(b.quaternion),b.setMatrixNeedsUpdate(),A.attachChild(b);const m=new me;m.setFreeDoF(W.EX,W.EY,W.EZ),b.addChild(m),m.makeClosure(d);const h=v.find(S=>S.name==="RIGHT_DIFFERENTIAL").child,y=new at;i.addChild(y);const w=new lt;w.setPosition(0,.7,0),y.addChild(w);const g=new at;g.setDoF(W.EZ),w.addChild(g);const x=new lt;x.setPosition(0,0,0),g.addChild(x);const P=new at;P.setDoF(W.EY),x.addChild(P);const T=new lt;h.getWorldPosition(T.position),T.setMatrixNeedsUpdate(),P.attachChild(T),T.position[1]=0,T.position[2]=0,T.setMatrixNeedsUpdate();const C=new at;h.addChild(C);const B=new lt;T.getWorldPosition(B.position),T.getWorldQuaternion(B.quaternion),B.setMatrixNeedsUpdate(),C.attachChild(B);const _=new me;_.setFreeDoF(W.EX,W.EY,W.EZ),B.addChild(_),_.makeClosure(T),pe=new We([v]),pe.setColor(15277667),Wt=new We([v]),Wt.setColor(15277667),Wt.setDrawThrough(!0),j.rotation.set(Math.PI/2,0,0),Yn(v,j),Ve=["LR_DRIVE","LM_DRIVE","LF_DRIVE","RR_DRIVE","RM_DRIVE","RF_DRIVE"].map(S=>{const M=new me;return M.setGoalDoF(W.X,W.Y,W.Z),v.traverse(E=>{if(E.name===S){const F=E.child;F.getWorldPosition(M.position),M.setMatrixWorldNeedsUpdate(),M.makeClosure(F)}}),M}),v.traverse(S=>{switch(S.name){case"JOINT1_ENC":S.setTargetValues(90*ht.DEG2RAD),S.targetSet=!0;break;case"JOINT2_ENC":S.setTargetValues(-18*ht.DEG2RAD),S.targetSet=!0;break;case"JOINT3_ENC":S.setTargetValues(-160*ht.DEG2RAD),S.targetSet=!0;break;case"JOINT4_ENC":S.setTargetValues(178*ht.DEG2RAD),S.targetSet=!0;break;case"JOINT5_ENC":S.setTargetValues(90*ht.DEG2RAD),S.targetSet=!0;break;case"RSM_AZ_ENC":S.setTargetValues(180*ht.DEG2RAD),S.targetSet=!0;break;case"RSM_EL_ENC":S.setTargetValues(90*ht.DEG2RAD),S.targetSet=!0;break}}),ze=new kn([v,...Ve]),st.add(j,pe,Wt)}),window.addEventListener("resize",()=>{const a=window.innerWidth,i=window.innerHeight,c=a/i;Q.setSize(a,i),At.aspect=c,At.updateProjectionMatrix()}),window.addEventListener("keydown",a=>{switch(a.key){case"w":H.setMode("translate");break;case"e":H.setMode("rotate");break;case"q":H.setSpace(H.space==="local"?"world":"local");break;case"f":qt.target.set(0,0,0),qt.update();break}}),Q.domElement.addEventListener("pointerdown",a=>{an.x=a.clientX,an.y=a.clientY})}function ai(){v.setPosition(N.position.x,v.position[1],N.position.z),v.setQuaternion(N.quaternion.x,N.quaternion.y,N.quaternion.z,N.quaternion.w),v.traverse(t=>{t.isJoint&&(t.dofValues.fill(0),t.setMatrixDoFNeedsUpdate())});let n="",e=0;for(let t=0;t<k.settleIterations;t++){v.updateMatrixWorld(!0),Ve.forEach((c,r)=>{c.child.getWorldPosition(Ht),ue.ray.origin.set(Ht[0],3,Ht[2]),ue.ray.direction.set(0,-1,0),ue.firstHitOnly=!0;let u=0;const f=ue.intersectObject(it,!0);f.length&&(u=f[0].point.y+.25),c.setPosition(Ht[0],u,Ht[2])}),Object.assign(ze,ri);const s=window.performance.now(),o=ze.solve(),a=window.performance.now()-s;if(e+=a,n+=a.toFixed(2)+"ms "+qn[o[0]]+`
`,!(o.filter(c=>c===Xe.TIMEOUT||c===Xe.STALLED).length!==0))break}n=n+`
Total: `+e.toFixed(2)+"ms",Tn.textContent=n,yn(j,v)}function bn(){requestAnimationFrame(bn),it.scale.z=k.terrainHeight,j&&(Zt&&k.solve?(ai(),Zt=!1):k.solve||(v.setPosition(N.position.x,N.position.y,N.position.z),v.setQuaternion(N.quaternion.x,N.quaternion.y,N.quaternion.z,N.quaternion.w),yn(j,v))),j&&(j.visible=k.displayMesh,pe.visible=k.displayIk,Wt.visible=k.displayIk),v&&!H.dragging&&(N.position.set(...v.position),N.quaternion.set(...v.quaternion)),j&&(ln.subVectors(X.position,X.target.position),X.target.position.copy(j.position),X.position.copy(j.position).add(ln)),H.visible=k.enableControls,H.enabled=k.enableControls,Q.render(st,At),Ne.update()}
